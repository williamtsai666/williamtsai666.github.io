<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>shell脚本(6)创建函数</title>
    <link href="/2018/02/24/shell-script-6-function/"/>
    <url>/2018/02/24/shell-script-6-function/</url>
    
    <content type="html"><![CDATA[<h2 id="基本的脚本函数"><a href="#基本的脚本函数" class="headerlink" title="基本的脚本函数"></a>基本的脚本函数</h2><p>函数是一个脚本代码块，你可以为其命名并在代码中任何位置重用。</p><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">第一种格式采用关键字 <span class="hljs-keyword">function</span>：<br><span class="hljs-keyword">function</span> name &#123; <br>    commands <br>&#125; <br><br>第二种格式更接近于其他编程语言:<br><span class="hljs-comment"># 函数名后的空括号表明正在定义的是一个函数</span><br><span class="hljs-function"><span class="hljs-title">name</span></span>() &#123; <br>commands <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> func1 &#123; <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is an example of a function&quot;</span> <br>&#125; <br> <br>func1 <span class="hljs-comment"># 使用函数名调用函数 </span><br><span class="hljs-comment"># 函数需要先定义后使用</span><br><span class="hljs-comment"># 同名函数，使用最后定义的函数</span><br><br></code></pre></td></tr></table></figure><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>bash  shell会把函数当作一个小型脚本，运行结束时会返回一个退出状态码</p><h3 id="默认退出状态码"><a href="#默认退出状态码" class="headerlink" title="默认退出状态码"></a>默认退出状态码</h3><p>默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量 <code>$? </code>来确定函数的退出状态码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test4 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># testing the exit status of a function </span><br><br><span class="hljs-function"><span class="hljs-title">func1</span></span>() &#123; <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;trying to display a non-existent file&quot;</span> <br>   <span class="hljs-built_in">ls</span> -l badfile <br>&#125; <br> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;testing the function: &quot;</span> <br>func1 <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The exit status is: $?&quot;</span> <br>$  <br>$ ./test4 <br>testing the <span class="hljs-keyword">function</span>: <br>trying to display a non-existent file <br><span class="hljs-built_in">ls</span>: badfile: No such file or directory <br>The <span class="hljs-built_in">exit</span> status is: 1 <br>$ <br></code></pre></td></tr></table></figure><h3 id="使用-return-命令"><a href="#使用-return-命令" class="headerlink" title="使用 return 命令"></a>使用 return 命令</h3><p>bash shell使用 return 命令来退出函数并返回特定的退出状态码。 return 命令允许指定一个整数值来定义函数的退出状态码，从而提供了一种简单的途径来编程设定函数退出状态码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test5 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># using the return command in a function </span><br> <br><span class="hljs-keyword">function</span> dbl &#123; <br>   <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter a value: &quot;</span> value <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;doubling the value&quot;</span> <br>   <span class="hljs-built_in">return</span> $[ <span class="hljs-variable">$value</span> * 2 ] <br>&#125; <br> <br>dbl <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The new value is $?&quot;</span> <br>$ <br><span class="hljs-comment"># 函数一结束就取返回值</span><br><span class="hljs-comment"># 退出状态码必须是0~255</span><br></code></pre></td></tr></table></figure><h3 id="使用函数输出"><a href="#使用函数输出" class="headerlink" title="使用函数输出"></a>使用函数输出</h3><p>可以将函数的输出保存到变量中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test5b <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># using the echo to return a value </span><br> <br><span class="hljs-keyword">function</span> dbl &#123; <br>   <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter a value: &quot;</span> value <br>   <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$value</span> * 2 ] <br>&#125; <br> <br>result=$(dbl) <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The new value is <span class="hljs-variable">$result</span>&quot;</span> <br>$  <br>$ ./test5b <br>Enter a value: 200 <br>The new value is 400 <br>$  <br></code></pre></td></tr></table></figure><h2 id="在函数中使用变量"><a href="#在函数中使用变量" class="headerlink" title="在函数中使用变量"></a>在函数中使用变量</h2><h3 id="向函数传递参数"><a href="#向函数传递参数" class="headerlink" title="向函数传递参数"></a>向函数传递参数</h3><p>bash shell会将函数当作小型脚本来对待,这意味着你可以像普通脚本那样向函数传递参数。函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在 <code>$0</code>变量中定义，函数命令行上的任何参数都会通过 <code>$1</code> 、 <code>$2</code> 等定义。也可以用特殊变量<code> $#</code> 来判断传给函数的参数数目</p><p>在脚本中指定函数时，必须将参数和函数放在同一行，像这样： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">func1 <span class="hljs-variable">$value1</span> 10<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash </span><br><span class="hljs-comment"># passing parameters to a function </span><br> <br><span class="hljs-keyword">function</span> addem &#123; <br>   <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -eq 0 ] || [ <span class="hljs-variable">$#</span> -gt 2 ] <br>   <span class="hljs-keyword">then</span> <br>      <span class="hljs-built_in">echo</span> -1 <br>   <span class="hljs-keyword">elif</span> [ <span class="hljs-variable">$#</span> -eq 1 ] <br>   <span class="hljs-keyword">then</span> <br>      <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> + <span class="hljs-variable">$1</span> ] <br>   <span class="hljs-keyword">else</span> <br>      <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> + <span class="hljs-variable">$2</span> ] <br>   <span class="hljs-keyword">fi</span> <br>   &#125; <br><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;Adding 10 and 15: &quot;</span> <br>value=$(addem 10 15) <br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$value</span> <br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取命令行中的参数 传递给函数</span><br>$ <span class="hljs-built_in">cat</span> test7 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># trying to access script parameters inside a function </span><br> <br><span class="hljs-keyword">function</span> func7 &#123; <br>   <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> * <span class="hljs-variable">$2</span> ] <br>&#125; <br> <br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -eq 2 ] <br><span class="hljs-keyword">then</span> <br>   value=$(func7 <span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span>) <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The result is <span class="hljs-variable">$value</span>&quot;</span> <br><span class="hljs-keyword">else</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: badtest1 a b&quot;</span> <br><span class="hljs-keyword">fi</span> <br>$  <br>$ ./test7 <br>Usage: badtest1 a b <br>$ ./test7 10 15 <br>The result is 150 <br>$ <br></code></pre></td></tr></table></figure><h3 id="在函数中处理变量"><a href="#在函数中处理变量" class="headerlink" title="在函数中处理变量"></a>在函数中处理变量</h3><h4 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1.全局变量"></a>1.全局变量</h4><p>全局变量是在shell脚本中任何地方都有效的变量。默认情况下，你在脚本中定义的任何变量都是全局变量。在函数外定义的变量可在函数内正常访问。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test8 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># using a global variable to pass a value </span><br><span class="hljs-keyword">function</span> dbl &#123; <br>   value=$[ <span class="hljs-variable">$value</span> * 2 ] <br>&#125; <br> <br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter a value: &quot;</span> value <br>dbl <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The new value is: <span class="hljs-variable">$value</span>&quot;</span> <br>$  <br>$ ./test8 <br>Enter a value: 450 <br>The new value is: 900 <br>$ <br></code></pre></td></tr></table></figure><h4 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2.局部变量"></a>2.局部变量</h4><p>函数内部使用的任何变量都可以被声明成局部变量。定义局部变量时，需要在变量名前加上local关键字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test9 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># demonstrating the local keyword </span><br> <br><span class="hljs-keyword">function</span> func1 &#123; <br>   <span class="hljs-built_in">local</span> temp=$[ <span class="hljs-variable">$value</span> + 5 ] <br>   result=$[ <span class="hljs-variable">$temp</span> * 2 ] <br>&#125; <br> <br>temp=4 <br>value=6 <br> <br>func1 <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The result is <span class="hljs-variable">$result</span>&quot;</span> <br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$temp</span> -gt <span class="hljs-variable">$value</span> ] <br><span class="hljs-keyword">then</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;temp is larger&quot;</span> <br><span class="hljs-keyword">else</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;temp is smaller&quot;</span> <br><span class="hljs-keyword">fi</span> <br>$  <br>$ ./test9 <br>The result is 22 <br>temp is smaller <br>$ <br></code></pre></td></tr></table></figure><h2 id="数组变量和函数"><a href="#数组变量和函数" class="headerlink" title="数组变量和函数"></a>数组变量和函数</h2><h3 id="向函数传数组参数"><a href="#向函数传数组参数" class="headerlink" title="向函数传数组参数"></a>向函数传数组参数</h3><p>需要将数组变量的值分解成单个的值，然后将这些值作为函数参数使用。在函数内部，可以将所有的参数重新组合成一个新的变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test11 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># adding values in an array </span><br><span class="hljs-keyword">function</span> addarray &#123; <br>   <span class="hljs-built_in">local</span> <span class="hljs-built_in">sum</span>=0 <br>   <span class="hljs-built_in">local</span> newarray <br>   newarray=($(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>)) <br>   <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;newarray[*]&#125;</span> <br>   <span class="hljs-keyword">do</span> <br>      <span class="hljs-built_in">sum</span>=$[ <span class="hljs-variable">$sum</span> + <span class="hljs-variable">$value</span> ] <br>   <span class="hljs-keyword">done</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-variable">$sum</span> <br>&#125; <br> <br>myarray=(1 2 3 4 5) <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The original array is: <span class="hljs-variable">$&#123;myarray[*]&#125;</span>&quot;</span> <br>arg1=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;myarray[*]&#125;</span>) <br>result=$(addarray <span class="hljs-variable">$arg1</span>) <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The result is <span class="hljs-variable">$result</span>&quot;</span> <br>$  <br>$ ./test11 <br>The original array is: 1 2 3 4 5 <br>The result is 15 <br>$ <br></code></pre></td></tr></table></figure><h3 id="从函数返回数组"><a href="#从函数返回数组" class="headerlink" title="从函数返回数组"></a>从函数返回数组</h3><p>从函数里向shell脚本传回数组变量也用类似的方法。函数用 echo 语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test12 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># returning an array value </span><br> <br><span class="hljs-keyword">function</span> arraydblr &#123; <br>   <span class="hljs-built_in">local</span> origarray <br>   <span class="hljs-built_in">local</span> newarray <br>   <span class="hljs-built_in">local</span> elements <br>   <span class="hljs-built_in">local</span> i <br>   origarray=($(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>)) <br>   newarray=($(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>)) <br>   elements=$[ <span class="hljs-variable">$#</span> - 1 ] <br>   <span class="hljs-keyword">for</span> (( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-variable">$elements</span>; i++ )) <br>   &#123; <br>      newarray[<span class="hljs-variable">$i</span>]=$[ <span class="hljs-variable">$&#123;origarray[$i]&#125;</span> * 2 ] <br>   &#125; <br>   <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;newarray[*]&#125;</span> <br>&#125; <br> <br>myarray=(1 2 3 4 5) <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The original array is: <span class="hljs-variable">$&#123;myarray[*]&#125;</span>&quot;</span> <br>arg1=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;myarray[*]&#125;</span>) <br>result=($(arraydblr <span class="hljs-variable">$arg1</span>)) <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The new array is: <span class="hljs-variable">$&#123;result[*]&#125;</span>&quot;</span> <br>$  <br>$ ./test12 <br>The original array is: 1 2 3 4 5 <br>The new array is: 2 4 6 8 10 <br></code></pre></td></tr></table></figure><h2 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 阶乘</span><br>$ <span class="hljs-built_in">cat</span> test13 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># using recursion </span><br> <br><span class="hljs-keyword">function</span> factorial &#123; <br>   <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> -eq 1 ] <br>   <span class="hljs-keyword">then</span> <br>      <span class="hljs-built_in">echo</span> 1 <br>   <span class="hljs-keyword">else</span> <br>      <span class="hljs-built_in">local</span> temp=$[ <span class="hljs-variable">$1</span> - 1 ] <br>      <span class="hljs-built_in">local</span> result=$(factorial <span class="hljs-variable">$temp</span>) <br>      <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$result</span> * <span class="hljs-variable">$1</span> ] <br>   <span class="hljs-keyword">fi</span> <br>&#125;   <br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Enter value: &quot;</span> value <br>result=$(factorial <span class="hljs-variable">$value</span>) <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The factorial of <span class="hljs-variable">$value</span> is: <span class="hljs-variable">$result</span>&quot;</span> <br>$  <br>$ ./test13 <br>Enter value: 5 <br>The factorial of 5 is: 120 <br>$ <br></code></pre></td></tr></table></figure><h2 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h2><p>bash shell允许创建函数库文件，然后在多个脚本中引用该库文件。</p><p>第一步是创建一个包含脚本中所需函数的公用库文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> myfuncs <br><span class="hljs-comment"># my script functions </span><br> <br><span class="hljs-keyword">function</span> addem &#123; <br>   <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> + <span class="hljs-variable">$2</span> ] <br>&#125; <br> <br><span class="hljs-keyword">function</span> multem &#123; <br>   <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> * <span class="hljs-variable">$2</span> ] <br>&#125; <br> <br><span class="hljs-keyword">function</span> divem &#123; <br>   <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$2</span> -ne 0 ] <br>   <span class="hljs-keyword">then</span> <br>      <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> / <span class="hljs-variable">$2</span> ] <br>   <span class="hljs-keyword">else</span> <br>      <span class="hljs-built_in">echo</span> -1 <br>   <span class="hljs-keyword">fi</span> <br>&#125; <br></code></pre></td></tr></table></figure><p>下一步是在用到这些函数的脚本文件中包含myfuncs库文件。</p><p>和环境变量一样，shell函数仅在定义它的shell会话内有效。如果你在shell命令行界面的提示符下运行myfuncs  shell脚本，shell会创建一个新的shell并在其中运行这个脚本。它会为那个新shell定义这三个函数，但当你运行另外一个要用到这些函数的脚本时，它们是无法使用的。</p><p>使用函数库的关键在于 source 命令。 source 命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用 source 命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。</p><p>source 命令有个快捷的别名，称作点操作符（dot  operator）。要在shell脚本中运行myfuncs库文件，只需添加下面这行： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">. ./myfuncs  <span class="hljs-comment"># 第1个点表示点操作符， 第2个点表示当前目录</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test14 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># using functions defined in a library file </span><br>. ./myfuncs <br> <br>value1=10 <br>value2=5 <br>result1=$(addem <span class="hljs-variable">$value1</span> <span class="hljs-variable">$value2</span>) <br>result2=$(multem <span class="hljs-variable">$value1</span> <span class="hljs-variable">$value2</span>) <br>result3=$(divem <span class="hljs-variable">$value1</span> <span class="hljs-variable">$value2</span>) <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The result of adding them is: <span class="hljs-variable">$result1</span>&quot;</span> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The result of multiplying them is: <span class="hljs-variable">$result2</span>&quot;</span> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The result of dividing them is: <span class="hljs-variable">$result3</span>&quot;</span> <br>$  <br>$ ./test14 <br>The result of adding them is: 15 <br>The result of multiplying them is: 50 <br>The result of dividing them is: 2 <br>$ <br></code></pre></td></tr></table></figure><h2 id="在命令行上使用函数"><a href="#在命令行上使用函数" class="headerlink" title="在命令行上使用函数"></a>在命令行上使用函数</h2><h3 id="在-bashrc-文件中定义函数"><a href="#在-bashrc-文件中定义函数" class="headerlink" title="在.bashrc 文件中定义函数"></a>在.bashrc 文件中定义函数</h3><p>bash shell在每次启动时都会在主目录下查找.bashrc文件并运行</p><h4 id="1-直接定义函数"><a href="#1-直接定义函数" class="headerlink" title="1.直接定义函数"></a>1.直接定义函数</h4><p>可以直接在主目录下的.bashrc文件中定义函数。把你写的函数放在文件末尾就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> .bashrc <br><span class="hljs-comment"># .bashrc </span><br> <br><span class="hljs-comment"># Source global definitions </span><br><span class="hljs-keyword">if</span> [ -r /etc/bashrc ]; <span class="hljs-keyword">then</span> <br>        . /etc/bashrc <br><span class="hljs-keyword">fi</span> <br><br><span class="hljs-comment"># 该函数会在下次启动新bash shell时生效。</span><br><span class="hljs-keyword">function</span> addem &#123; <br>   <span class="hljs-built_in">echo</span> $[ <span class="hljs-variable">$1</span> + <span class="hljs-variable">$2</span> ] <br>&#125; <br>$ <br></code></pre></td></tr></table></figure><h4 id="2-读取函数文件"><a href="#2-读取函数文件" class="headerlink" title="2.读取函数文件"></a>2.读取函数文件</h4><p>只要是在shell脚本中，都可以用 source 命令（点操作符）将库文件中的函数添加到你的.bashrc脚本中。shell还会将定义好的函数传给子shell进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> .bashrc <br><span class="hljs-comment"># .bashrc </span><br> <br><span class="hljs-comment"># Source global definitions </span><br><span class="hljs-keyword">if</span> [ -r /etc/bashrc ]; <span class="hljs-keyword">then</span> <br>        . /etc/bashrc <br><span class="hljs-keyword">fi</span> <br> <br>. /home/rich/libraries/myfuncs <br>$ <br></code></pre></td></tr></table></figure><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell脚本(5)控制脚本</title>
    <link href="/2018/02/23/shell-script-5-script-control/"/>
    <url>/2018/02/23/shell-script-5-script-control/</url>
    
    <content type="html"><![CDATA[<h2 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号</h2><p>Linux利用信号与运行在系统中的进程进行通信。</p><h3 id="Linux-信号"><a href="#Linux-信号" class="headerlink" title="Linux 信号"></a>Linux 信号</h3><p>Linux系统和应用程序可以生成超过30个信号，一下是常用的Linux系统信号。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span> SIGHUP  挂起进程 <br><span class="hljs-symbol">2 </span> SIGINT  终止进程<br><span class="hljs-symbol">3 </span> SIGQUIT  停止进程 <br><span class="hljs-symbol">9 </span> SIGKILL  无条件终止进程 <br><span class="hljs-symbol">15 </span> SIGTERM  尽可能终止进程 <br><span class="hljs-symbol">17 </span> SIGSTOP  无条件停止进程，但不是终止进程 <br><span class="hljs-symbol">18 </span> SIGTSTP  停止或暂停进程，但不终止进程 <br><span class="hljs-symbol">19 </span> SIGCONT  继续运行停止的进程 <br></code></pre></td></tr></table></figure><p>默认情况下，bash shell会忽略收到的任何 <code>SIGQUIT (3)</code> 和 <code>SIGTERM (5) </code>信号（正因为这样，交互式shell才不会被意外终止）。但是bash shell会处理收到的 <code>SIGHUP (1)</code> 和<code> SIGINT (2)</code> 信号。</p><p>如果bash  shell收到了 SIGHUP 信号，比如当你要离开一个交互式shell，它就会退出。但在退出之前，它会将 SIGHUP 信号传给所有由该shell所启动的进程（包括正在运行的shell脚本）。 </p><p>通过 SIGINT 信号，可以中断shell。Linux内核会停止为shell分配CPU处理时间。这种情况发生时，shell会将 SIGINT 信号传给所有由它所启动的进程，以此告知出现的状况。 </p><h3 id="生成信号"><a href="#生成信号" class="headerlink" title="生成信号"></a>生成信号</h3><p>bash  shell允许用键盘上的组合键生成两种基本的Linux信号。</p><h4 id="中断进程"><a href="#中断进程" class="headerlink" title="中断进程"></a>中断进程</h4><p><code>Ctrl</code>+<code>C</code>组合键会生成 <code>SIGINT </code>信号，并将其发送给当前在shell中运行的所有进程。</p><h4 id="暂停进程"><a href="#暂停进程" class="headerlink" title="暂停进程"></a>暂停进程</h4><p><code>Ctrl</code>+<code>Z</code>组合键会生成一个 <code>SIGTSTP</code> 信号，停止shell中运行的任何进程。停止（stopping）进程跟终止（terminating）进程不同：停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行。</p><h3 id="捕获信号"><a href="#捕获信号" class="headerlink" title="捕获信号"></a>捕获信号</h3><p><code>trap</code>命令允许你来指定shell脚本要监看并从shell中拦截的Linux信号。如果脚本收到了 trap 命令中列出的信号，该信号不再由shell处理，而是交由本地处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># trap 命令的格式是： </span><br><span class="hljs-built_in">trap</span> commands signals <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test1.sh <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># Testing signal trapping </span><br><span class="hljs-comment"># </span><br><span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;echo &#x27; Sorry! I have trapped Ctrl-C&#x27;&quot;</span> SIGINT <br><span class="hljs-comment"># </span><br><span class="hljs-built_in">echo</span> This is a <span class="hljs-built_in">test</span> script <br><span class="hljs-comment"># </span><br>count=1 <br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$count</span> -le 10 ] <br><span class="hljs-keyword">do</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Loop #<span class="hljs-variable">$count</span>&quot;</span> <br>   <span class="hljs-built_in">sleep</span> 1 <br>   count=$[ <span class="hljs-variable">$count</span> + 1 ] <br><span class="hljs-keyword">done</span> <br><span class="hljs-comment"># </span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is the end of the test script&quot;</span> <br><span class="hljs-comment"># </span><br><br>$ ./test1.sh <br>This is a <span class="hljs-built_in">test</span> script <br>Loop <span class="hljs-comment">#1 </span><br>Loop <span class="hljs-comment">#2 </span><br>^C Sorry! I have trapped Ctrl-C <br></code></pre></td></tr></table></figure><h3 id="捕获脚本退出"><a href="#捕获脚本退出" class="headerlink" title="捕获脚本退出"></a>捕获脚本退出</h3><p>要捕获shell脚本的退出，只要在 trap 命令后加上 EXIT 信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test2.sh <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># Trapping the script exit </span><br><span class="hljs-comment"># </span><br><span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;echo Goodbye...&quot;</span> EXIT <br><span class="hljs-comment"># </span><br>count=1 <br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$count</span> -le 5 ] <br><span class="hljs-keyword">do</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Loop #<span class="hljs-variable">$count</span>&quot;</span> <br>   <span class="hljs-built_in">sleep</span> 1 <br>   count=$[ <span class="hljs-variable">$count</span> + 1 ] <br><span class="hljs-keyword">done</span> <br><span class="hljs-comment"># </span><br>$ <br>$ ./test2.sh <br>Loop <span class="hljs-comment">#1 </span><br>Loop <span class="hljs-comment">#2 </span><br>Loop <span class="hljs-comment">#3 </span><br>Loop <span class="hljs-comment">#4 </span><br>Loop <span class="hljs-comment">#5 </span><br>Goodbye... <br>$ <br><span class="hljs-comment"># 提前退出脚本，同样能够捕获到 EXIT</span><br>$ ./test2.sh <br>Loop <span class="hljs-comment">#1 </span><br>Loop <span class="hljs-comment">#2 </span><br>Loop <span class="hljs-comment">#3 </span><br>^CGoodbye... <br> <br></code></pre></td></tr></table></figure><h3 id="修改或移除捕获"><a href="#修改或移除捕获" class="headerlink" title="修改或移除捕获"></a>修改或移除捕获</h3><p>要想在脚本中的不同位置进行不同的捕获处理，只需重新使用带有新选项的 trap 命令。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test3.sh <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># Modifying a set trap </span><br><span class="hljs-comment"># </span><br><span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;echo &#x27; Sorry... Ctrl-C is trapped.&#x27;&quot;</span> SIGINT <br><span class="hljs-comment"># </span><br>count=1 <br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$count</span> -le 5 ] <br><span class="hljs-keyword">do</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Loop #<span class="hljs-variable">$count</span>&quot;</span> <br>   <span class="hljs-built_in">sleep</span> 1 <br>   count=$[ <span class="hljs-variable">$count</span> + 1 ] <br><span class="hljs-keyword">done</span> <br><span class="hljs-comment"># </span><br><span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;echo &#x27; I modified the trap!&#x27;&quot;</span> SIGINT <br><span class="hljs-comment"># </span><br>count=1 <br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$count</span> -le 5 ] <br><span class="hljs-keyword">do</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Second Loop #<span class="hljs-variable">$count</span>&quot;</span> <br>   <span class="hljs-built_in">sleep</span> 1 <br>   count=$[ <span class="hljs-variable">$count</span> + 1 ] <br><span class="hljs-keyword">done</span> <br><span class="hljs-comment"># </span><br>$ <br>$ ./test3.sh <br>Loop <span class="hljs-comment">#1 </span><br>Loop <span class="hljs-comment">#2 </span><br>Loop <span class="hljs-comment">#3 </span><br>^C Sorry... Ctrl-C is trapped. <br>Loop <span class="hljs-comment">#4 </span><br>Loop <span class="hljs-comment">#5 </span><br>Second Loop <span class="hljs-comment">#1 </span><br>Second Loop <span class="hljs-comment">#2 </span><br>^C I modified the <span class="hljs-built_in">trap</span>! <br>Second Loop <span class="hljs-comment">#3 </span><br>Second Loop <span class="hljs-comment">#4 </span><br>Second Loop <span class="hljs-comment">#5 </span><br>$ <br><br><span class="hljs-comment"># 删除已设置好的捕获。在trap 命令与希望恢复默认行为的信号列表之间加上两个破折号</span><br><span class="hljs-comment"># 也可以在 trap 命令后使用单破折号来恢复信号的默认行为,单破折号和双破折号都可以正常发挥作用。</span><br><span class="hljs-comment"># Remove the trap </span><br><span class="hljs-built_in">trap</span> -- SIGINT <br><br></code></pre></td></tr></table></figure><h2 id="以后台模式运行脚本"><a href="#以后台模式运行脚本" class="headerlink" title="以后台模式运行脚本"></a>以后台模式运行脚本</h2><p>在后台模式中，进程运行时不会和终端会话上的 <code>STDIN</code> 、 <code>STDOUT</code>以及<code>STDERR</code>关联</p><h3 id="后台运行脚本"><a href="#后台运行脚本" class="headerlink" title="后台运行脚本"></a>后台运行脚本</h3><p>以后台模式运行shell脚本非常简单。只要在命令后加个<code>&amp;</code>符就行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">command</span> &amp;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test4.sh <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># Test running in the background </span><br><span class="hljs-comment"># </span><br>count=1 <br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$count</span> -le 10 ] <br><span class="hljs-keyword">do</span> <br>   <span class="hljs-built_in">sleep</span> 1 <br>   count=$[ <span class="hljs-variable">$count</span> + 1 ] <br><span class="hljs-keyword">done</span> <br><span class="hljs-comment"># </span><br>$ <br>$ ./test4.sh &amp;  <span class="hljs-comment"># 将命令作为系统中的一个独立的后台进程运行</span><br>[1] 3231  <span class="hljs-comment"># [shell分配给后台进程的作业号] Linux系统分配给进程的进程ID（PID）</span><br><br><span class="hljs-comment"># 当后台进程结束时，它会在终端上显示出一条消息</span><br>[1]   Done                    ./test4.sh <br><br><span class="hljs-comment"># 当后台进程运行时，它仍然会使用终端显示器来显示STDOUT和STDERR消息</span><br></code></pre></td></tr></table></figure><h2 id="在非控制台下运行脚本"><a href="#在非控制台下运行脚本" class="headerlink" title="在非控制台下运行脚本"></a>在非控制台下运行脚本</h2><p><code>nohup</code>命令运行了另外一个命令来阻断所有发送给该进程的 SIGHUP 信号。这会在退出终端会话时阻止进程退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">nohup</span> ./test1.sh &amp; <br>[1] 3856 <br>$ <span class="hljs-built_in">nohup</span>: ignoring input and appending output to <span class="hljs-string">&#x27;nohup.out&#x27;</span> <br> <br><span class="hljs-comment"># 由于 nohup命令会解除终端与进程的关联，进程也就不再同STDOUT和STDERR联系在一起。为了保存该命令产生的输出，nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为nohup.out的文件中。</span><br></code></pre></td></tr></table></figure><h2 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h2><p>启动、停止、终止以及恢复作业的这些功能统称为作业控制。</p><h3 id="查看作业"><a href="#查看作业" class="headerlink" title="查看作业"></a>查看作业</h3><p>作业控制中的关键命令是 jobs 命令。 jobs 命令允许查看shell当前正在处理的作业。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">jobs</span> -l <br>[1]+  1897 Stopped                 ./test10.sh <br>[2]-  1917 Running                 ./test10.sh &gt; test10.out &amp; <br><br><span class="hljs-comment"># jobs命令参数</span><br>-l  列出进程的PID以及作业号 <br>-n  只列出上次shell发出的通知后改变了状态的作业 <br>-p  只列出作业的PID <br>-r  只列出运行中的作业 <br>-s  只列出已停止的作业 <br><span class="hljs-comment"># +-号解释</span><br>带加号的作业会被当做默认作业。在使用作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象。<br>当前的默认作业完成处理后，带减号的作业成为下一个默认作业。<br>任何时候都只有一个带加号的作业和一个带减号的作业，不管shell中有多少个正在运行的作业。<br></code></pre></td></tr></table></figure><h3 id="重启停止的作业"><a href="#重启停止的作业" class="headerlink" title="重启停止的作业"></a>重启停止的作业</h3><p>在bash作业控制中，可以将已停止的作业作为后台进程或前台进程重启。要以后台模式重启一个作业，可用<code>bg</code>命令加上作业号。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./test11.sh <br>^Z <br>[1]+  Stopped                 ./test11.sh <br>$ <br><span class="hljs-comment"># 因为该作业是默认作业（带+号），只需要使用 bg 命令就可以将其以后台模式重启</span><br>$ <span class="hljs-built_in">bg</span> <br>[1]+ ./test11.sh &amp; <br>$ <br>$ <span class="hljs-built_in">jobs</span> <br>[1]+  Running                 ./test11.sh &amp; <br>$ <br></code></pre></td></tr></table></figure><p>要以前台模式重启作业，可用带有作业号的 <code>fg</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">fg</span> 2 <br>./test12.sh <br>This is the script<span class="hljs-string">&#x27;s end... </span><br><span class="hljs-string">$ </span><br></code></pre></td></tr></table></figure><h2 id="调整谦让度"><a href="#调整谦让度" class="headerlink" title="调整谦让度"></a>调整谦让度</h2><p>在多任务操作系统中(Linux)，内核负责将CPU时间分配给系统上运行的每个进程。调度优先级（scheduling  priority）是内核分配给进程的CPU时间（相对于其他进程）。在Linux系统中，由shell启动的所有进程的调度优先级默认都是相同的。<br>调度优先级是个整数值，从-20（最高优先级）到+19（最低优先级）。默认情况下，bash shell以优先级0来启动所有进程。</p><h3 id="nice-命令"><a href="#nice-命令" class="headerlink" title="nice 命令"></a>nice 命令</h3><p>nice 命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级运行，只要用 nice的 -n 命令行来指定新的优先级级别。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">nice</span> -n 10 ./test4.sh &gt; test4.out &amp; <br>[1] 4973 <br>$ <br>$ ps -p 4973 -o pid,ppid,ni,cmd <br>  PID  PPID  NI CMD <br> 4973  4721  10 /bin/bash ./test4.sh <br>$<br><span class="hljs-comment"># nice 命令阻止普通系统用户来提高命令的优先级</span><br><span class="hljs-comment"># nice命令可以在破折号后面跟上优先级</span><br>$ <span class="hljs-built_in">nice</span> -10 ./test4.sh &gt; test4.out &amp; <br></code></pre></td></tr></table></figure><h3 id="renice-命令"><a href="#renice-命令" class="headerlink" title="renice 命令"></a>renice 命令</h3><p>renice命令可以修改系统上已运行命令的优先级。renice 命令会自动更新当前运行进程的调度优先级。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -n 指定优先级 -p指定进程号</span><br>$ renice -n 10 -p 5055 <br>5055: old priority 0, new priority 10 <br>$ <br><span class="hljs-comment"># renice命令有一些限制：</span><br>1.只能对属于你的进程执行 renice<br>2.只能通过 renice 降低进程的优先级<br>3. root用户可以通过 renice 来任意调整进程的优先级<br></code></pre></td></tr></table></figure><h2 id="定时运行作业"><a href="#定时运行作业" class="headerlink" title="定时运行作业"></a>定时运行作业</h2><h3 id="用-at-命令来计划执行作业"><a href="#用-at-命令来计划执行作业" class="headerlink" title="用 at 命令来计划执行作业"></a>用 at 命令来计划执行作业</h3><p>​at 命令允许指定Linux系统何时运行脚本。 at 命令会将作业提交到队列中，指定shell何时运行该作业。 at 的守护进程 atd 会以后台模式运行，检查作业队列来运行作业。大多数Linux发行版会在启动时运行此守护进程。</p><p>​atd 守护进程会检查系统上的一个特殊目录（通常位于&#x2F;var&#x2F;spool&#x2F;at）来获取用 at 命令提交的作业。默认情况下， atd 守护进程会每60秒检查一下这个目录。有作业时， atd 守护进程会检查作业设置运行的时间。如果时间跟当前时间匹配， atd 守护进程就会运行此作业。 </p><h4 id="1-at命令的格式"><a href="#1-at命令的格式" class="headerlink" title="1.at命令的格式"></a>1.at命令的格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">at [-f filename] time <br>----------------------------<br>默认情况下， at 命令会将 STDIN 的输入放到队列中。用-f参数来指定用于读取命令（脚本文件）的文件名<br>time 参数指定了Linux系统何时运行该作业。如果你指定的时间已经错过， at 命令会在第二天的那个时间运行指定的作业。<br>时间格式:<br>标准的小时和分钟格式，比如10:15。 <br>AM/PM指示符，比如10:15 PM。 <br>特定可命名时间，比如now、noon、midnight或者teatime（4 PM）。 <br>除了指定运行作业的时间，也可以通过不同的日期格式指定特定的日期。 <br>标准日期格式，比如MMDDYY、MM/DD/YY或DD.MM.YY。 <br>文本日期，比如Jul 4或Dec 25，加不加年份均可。 <br>你也可以指定时间增量。 <br>  当前时间+25 min <br>  明天10:15 PM <br>  10:15+7天 <br>  <br>作业会被提交到作业队列（job queue）。作业队列会保存通过at命令提交的待处理的作业。<br>针对不同优先级，存在26种不同的作业队列。作业队列通常用小写字母a~z和大写字母A~Z来指代。<br>作业队列的字母排序越高，作业运行的优先级就越低（更高的 <span class="hljs-built_in">nice</span> 值）。默认情况下，at 的作业会被提交到 a作业队列。如果想以更高优先级运行作业，可以用 -q 参数指定不同的队列字母。 <br></code></pre></td></tr></table></figure><h4 id="2-获取作业的输出"><a href="#2-获取作业的输出" class="headerlink" title="2.获取作业的输出"></a>2.获取作业的输出</h4><p>当作业在Linux系统上运行时，显示器并不会关联到该作业。Linux系统会将提交该作业的用户的电子邮件地址作为 STDOUT 和 STDERR 。任何发到 STDOUT 或 STDERR 的输出都会通过邮件系统发送给该用户。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ at -f test13.sh now <br><span class="hljs-comment"># at 命令利用 sendmail 应用程序来发送邮件。最好在脚本中对 STDOUT 和 STDERR 进行重定向</span><br></code></pre></td></tr></table></figure><h4 id="3-列出等待的作业"><a href="#3-列出等待的作业" class="headerlink" title="3.列出等待的作业"></a>3.列出等待的作业</h4><p>atq 命令可以查看系统中有哪些作业在等待。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ atq <br>20      2015-07-14 13:03 = Christine <br></code></pre></td></tr></table></figure><h4 id="4-删除作业"><a href="#4-删除作业" class="headerlink" title="4.删除作业"></a>4.删除作业</h4><p>atrm 命令来删除等待中的作业</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ atq <br>18      2015-07-15 13:03 a Christine <br>17      2015-07-14 16:00 a Christine <br>19      2015-07-14 13:30 a Christine <br>$ <br><span class="hljs-comment"># 指定想要删除的作业号</span><br><span class="hljs-comment"># 只能删除你提交的作业</span><br>$ atrm 18 <br>$ <br>$ atq <br>17      2015-07-14 16:00 a Christine <br>19      2015-07-14 13:30 a Christine <br>$ <br></code></pre></td></tr></table></figure><h3 id="安排需要定期执行的脚本"><a href="#安排需要定期执行的脚本" class="headerlink" title="安排需要定期执行的脚本"></a>安排需要定期执行的脚本</h3><p>Linux系统使用cron程序来安排要定期执行的作业。cron程序会在后台运行并检查一个特殊的表（被称作cron时间表），以获知已安排执行的作业。</p><h4 id="1-cron时间表"><a href="#1-cron时间表" class="headerlink" title="1.cron时间表"></a>1.cron时间表</h4><p>cron时间表采用一种特别的格式来指定作业何时运行。其格式如下： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">min hour dayofmonth month dayofweek <span class="hljs-built_in">command</span><br>----------------------------------------------------------------------------------<br>文本值（mon、tue、wed、thu、fri、sat、sun）或数值（0为周日，6为周六）来指定dayofweek表项。<br>*通配符<br><br><span class="hljs-comment"># 每天的10:15运行一个命令</span><br>15 10 * * * <span class="hljs-built_in">command</span> <br><span class="hljs-comment"># 每周一4:15 PM运行的命令</span><br>15 16 * * 1 <span class="hljs-built_in">command</span><br><span class="hljs-comment"># 命令列表必须指定要运行的命令或脚本的全路径名</span><br>15 10 * * * /home/rich/test4.sh &gt; test4out <br><br></code></pre></td></tr></table></figure><h4 id="2-构建cron时间表"><a href="#2-构建cron时间表" class="headerlink" title="2.构建cron时间表"></a>2.构建cron时间表</h4><p>每个系统用户（包括root用户）都可以用自己的cron时间表来运行安排好的任务。Linux提供了 crontab 命令来处理cron时间表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ crontab -l <br>no crontab <span class="hljs-keyword">for</span> rich <br>$ <br><span class="hljs-comment"># 默认情况下，用户的cron时间表文件并不存在。</span><br><span class="hljs-comment"># 要为cron时间表添加条目，可以用 -e 选项。在添加条目时， crontab 命令会启用一个文本编辑器，使用已有的cron时间表作为文件内容（或者是一个空文件，如果时间表不存在的话） </span><br><span class="hljs-variable">$crontab</span> -e<br><br></code></pre></td></tr></table></figure><h4 id="3-浏览cron目录"><a href="#3-浏览cron目录" class="headerlink" title="3.浏览cron目录"></a>3.浏览cron目录</h4><p>如果你创建的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便。有4个基本目录：hourly、daily、monthly和weekly</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> /etc/cron.*ly <br>/etc/cron.daily: <br>/etc/cron.hourly: <br>/etc/cron.monthly:<br>/etc/cron.weekly: <br><br><span class="hljs-comment"># 如果脚本需要每天运行一次，只要将脚本复制到daily目录，cron就会每天执行它</span><br></code></pre></td></tr></table></figure><h4 id="4-anacron程序"><a href="#4-anacron程序" class="headerlink" title="4.anacron程序"></a>4.anacron程序</h4><p>cron程序的唯一问题是它假定Linux系统是7×24小时运行的。如果某个作业在cron时间表中安排运行的时间已到，但这时候Linux系统处于关机状态，那么这个作业就不会被运行。当系统开机时，cron程序不会再去运行那些错过的作业。</p><p>如果anacron知道某个作业错过了执行时间，它会尽快运行该作业。这意味着如果Linux系统关机了几天，当它再次开机时，原定在关机期间运行的作业会自动运行。</p><p>anacron程序只会处理位于cron目录的程序，比如&#x2F;etc&#x2F;cron.monthly。它用时间戳来决定作业是否在正确的计划间隔内运行了。每个cron目录都有个时间戳文件，该文件位于&#x2F;var&#x2F;spool&#x2F; anacron</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo <span class="hljs-built_in">cat</span> /var/spool/anacron/cron.monthly <br>20150626 <br>$ <br><span class="hljs-comment"># anacron程序使用自己的时间表（通常位于/etc/anacrontab）来检查作业目录。</span><br>$ sudo <span class="hljs-built_in">cat</span> /etc/anacrontab <br><span class="hljs-comment">#period in days   delay in minutes   job-identifier   command </span><br>1       5       cron.daily              <span class="hljs-built_in">nice</span> run-parts /etc/cron.daily <br><br>anacron时间表的基本格式： <br>period delay identifier <span class="hljs-built_in">command</span> <br><span class="hljs-comment"># run-parts程序负责运行目录中传给它的任何脚本</span><br><span class="hljs-comment"># anacron不会运行位于/etc/cron.hourly的脚本。程序不会处理执行时间需求小于一天的脚本。 </span><br></code></pre></td></tr></table></figure><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell脚本(4)呈现数据</title>
    <link href="/2018/02/22/shell-script-4-presenting-data/"/>
    <url>/2018/02/22/shell-script-4-presenting-data/</url>
    
    <content type="html"><![CDATA[<h2 id="理解输入和输出"><a href="#理解输入和输出" class="headerlink" title="理解输入和输出"></a>理解输入和输出</h2><p>目前有两种显示脚本输出的方法： 1.在显示器屏幕上显示输出 2.将输出重定向到文件中 </p><h3 id="标准文件描述符"><a href="#标准文件描述符" class="headerlink" title="标准文件描述符"></a>标准文件描述符</h3><p>Linux系统将每个对象当作文件处理。这包括输入和输出进程。Linux用文件描述符(file  descriptor)来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多可以有九个文件描述符。出于特殊目的，bash shell保留了前三个文件描述符（ 0 、 1 和 2 ）</p><p> Linux的标准文件描述符</p><table><thead><tr><th>文件描述符</th><th>缩 写</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>STDIN</td><td>标准输入</td></tr><tr><td>1</td><td>STDOUT</td><td>标准输出</td></tr><tr><td>2</td><td>STDERR</td><td>标准错误</td></tr></tbody></table><h4 id="1-STDIN"><a href="#1-STDIN" class="headerlink" title="1.STDIN"></a>1.STDIN</h4><p><code>STDIN</code>文件描述符代表shell的标准输入。对终端界面来说，标准输入是键盘。shell从<code> STDIN</code>文件描述符对应的键盘获得输入，在用户输入时处理每个字符。</p><p>在使用输入重定向符号（ &lt; ）时，Linux会用重定向指定的文件来替换标准输入文件描述符,许多bash命令能接受 STDIN 的输入，尤其是没有在命令行上指定文件的话</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当在命令行上只输入cat命令时，它会从STDIN接受输入。输入一行，cat命令就会显示出一行。</span><br>$ <span class="hljs-built_in">cat</span> <br>this is a <span class="hljs-built_in">test</span> <br>this is a <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 重定向 用testfile文件中的行作为输入</span><br>$ <span class="hljs-built_in">cat</span> &lt; testfile <br></code></pre></td></tr></table></figure><h4 id="2-STDOUT"><a href="#2-STDOUT" class="headerlink" title="2.STDOUT"></a>2.STDOUT</h4><p><code>STDOUT</code> 文件描述符代表shell的标准输出。在终端界面上，标准输出就是终端显示器。shell的所有输出（包括shell中运行的程序和脚本）会被定向到标准输出中，也就是显示器。默认情况下，大多数bash命令会将输出导向 <code>STDOUT </code>文件描述符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出重定向</span><br>$ <span class="hljs-built_in">ls</span> -l &gt; test2 <br><span class="hljs-comment"># 输出追加</span><br>$ <span class="hljs-built_in">who</span> &gt;&gt; test2 <br><span class="hljs-comment"># 输出错误时</span><br>$ <span class="hljs-built_in">ls</span> -al badfile &gt; test3 <br><span class="hljs-built_in">ls</span>: cannot access badfile: No such file or directory <br>$ <span class="hljs-built_in">cat</span> test3 <br>$ <br><br>当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错误。test3文件创建成功了，只是里面是空的。 <br>shell对于错误消息的处理是跟普通输出分开的。如果你创建了在后台模式下运行的shell脚本，通常你必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些信息是不会出现在日志文件中的。<br></code></pre></td></tr></table></figure><h4 id="3-STDERR"><a href="#3-STDERR" class="headerlink" title="3.STDERR"></a>3.STDERR</h4><p>shell通过特殊的 <code>STDERR</code> 文件描述符来处理错误消息。<code>STDERR</code>文件描述符代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。 默认情况下， <code>STDERR </code>文件描述符会和 <code>STDOUT </code>文件描述符指向同样的地方。也就是说，默认情况下，错误消息也会输出到显示器输出中。</p><h3 id="重定向错误"><a href="#重定向错误" class="headerlink" title="重定向错误"></a>重定向错误</h3><h4 id="1-只重定向错误"><a href="#1-只重定向错误" class="headerlink" title="1.只重定向错误"></a>1.只重定向错误</h4><p><code>STDERR</code>文件描述符被设成 2 。可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。该值必须紧紧地放在重定向符号前，否则不会工作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> -al badfile 2&gt; test4 <br>$ <span class="hljs-built_in">cat</span> test4 <br><span class="hljs-built_in">ls</span>: cannot access badfile: No such file or directory <br>$ <br><span class="hljs-comment"># 只有错误消息被重定向到文件</span><br>$ <span class="hljs-built_in">ls</span> -al <span class="hljs-built_in">test</span> badtest test2 2&gt; test5 <br>-rw-rw-r-- 1 rich rich 158 2014-10-16 11:32 test2 <br>$ <span class="hljs-built_in">cat</span> test5 <br><span class="hljs-built_in">ls</span>: cannot access <span class="hljs-built_in">test</span>: No such file or directory <br><span class="hljs-built_in">ls</span>: cannot access badtest: No such file or directory <br>$ <br></code></pre></td></tr></table></figure><h4 id="2-重定向错误和数据"><a href="#2-重定向错误和数据" class="headerlink" title="2. 重定向错误和数据"></a>2. 重定向错误和数据</h4><p>如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 正常输出STDOUT 重定向到test7文件</span><br><span class="hljs-comment"># 错误消息STDERR 重定向到test6文件</span><br>$ <span class="hljs-built_in">ls</span> -al <span class="hljs-built_in">test</span> test2 test3 badtest 2&gt; test6 1&gt; test7 <br>$ <span class="hljs-built_in">cat</span> test6 <br><span class="hljs-built_in">ls</span>: cannot access <span class="hljs-built_in">test</span>: No such file or directory <br><span class="hljs-built_in">ls</span>: cannot access badtest: No such file or directory <br>$ <span class="hljs-built_in">cat</span> test7 <br>-rw-rw-r-- 1 rich rich 158 2014-10-16 11:32 test2 <br>-rw-rw-r-- 1 rich rich   0 2014-10-16 11:33 test3 <br>$ <br><br><span class="hljs-comment"># 将STDERR和STDOUT的输出重定向到同一个输出文件,使用特殊的重定向符号 &amp;&gt;</span><br>$ <span class="hljs-built_in">ls</span> -al <span class="hljs-built_in">test</span> test2 test3 badtest &amp;&gt; test7 <br>$ <span class="hljs-built_in">cat</span> test7 <br><span class="hljs-built_in">ls</span>: cannot access <span class="hljs-built_in">test</span>: No such file or directory <br><span class="hljs-built_in">ls</span>: cannot access badtest: No such file or directory <br>-rw-rw-r-- 1 rich rich 158 2014-10-16 11:32 test2 <br>-rw-rw-r-- 1 rich rich   0 2014-10-16 11:33 test3 <br>$ <br><span class="hljs-comment"># 当使用 &amp;&gt; 符时，命令生成的所有输出都会发送到同一位置，包括数据和错误。</span><br><span class="hljs-comment"># 为了避免错误信息散落在输出文件中，相较于标准输出，bash shell自动赋予了错误消息更高的优先级。</span><br><br></code></pre></td></tr></table></figure><h2 id="在脚本中重定向输出"><a href="#在脚本中重定向输出" class="headerlink" title="在脚本中重定向输出"></a>在脚本中重定向输出</h2><h3 id="临时重定向"><a href="#临时重定向" class="headerlink" title="临时重定向"></a>临时重定向</h3><p>如果想在脚本中生成错误消息，可以将单独的一行输出重定向到 STDERR 。使用输出重定向符来将输出信息重定向到 STDERR 文件描述符。在重定向到文件描述符时，你必须在文件描述符数字之前加一个 &amp;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test8 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># testing STDERR messages </span><br> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is an error&quot;</span> &gt;&amp;2 <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is normal output&quot;</span> <br>$ <br>$ ./test8 <br>This is an error <br>This is normal output <br><span class="hljs-comment"># 默认情况下，Linux会将 STDERR 导向 STDOUT 。所以上面的结果输出正常，但是，如果你在运行脚本时重定向了STDERR ，脚本中所有导向 STDERR 的文本都会被重定向。</span><br><br>$ ./test8 2&gt; test9 <br>This is normal output <br>$ <span class="hljs-built_in">cat</span> test9 <br>This is an error <br>$ <br></code></pre></td></tr></table></figure><h3 id="永久重定向"><a href="#永久重定向" class="headerlink" title="永久重定向"></a>永久重定向</h3><p>如果脚本中有大量数据需要重定向，那重定向每个 echo 语句就会很烦琐。可以用 exec 命令告诉shell在脚本执行期间重定向某个特定文件描述符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test10 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># redirecting all output to a file </span><br><span class="hljs-built_in">exec</span> 1&gt;testout <br> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is a test of redirecting all output&quot;</span> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;from a script to another file.&quot;</span> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;without having to redirect every individual line&quot;</span> <br>$ ./test10 <br>$ <span class="hljs-built_in">cat</span> testout <br>This is a <span class="hljs-built_in">test</span> of redirecting all output <br>from a script to another file. <br>without having to redirect every individual line <br>$ <br><span class="hljs-comment"># exec 命令会启动一个新shell并将 STDOUT 文件描述符重定向到文件。脚本中发给 STDOUT 的所有输出会被重定向到文件。 </span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 可以在脚本执行过程中重定向 STDOUT</span><br>$ <span class="hljs-built_in">cat</span> test11 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># redirecting output to different locations </span><br> <br><span class="hljs-built_in">exec</span> 2&gt;testerror <br> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is the start of the script&quot;</span> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;now redirecting all output to another location&quot;</span> <br> <br><span class="hljs-built_in">exec</span> 1&gt;testout <br> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This output should go to the testout file&quot;</span> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;but this should go to the testerror file&quot;</span> &gt;&amp;2 <br>$ <br>$ ./test11 <br>This is the start of the script <br>now redirecting all output to another location <br>$ <span class="hljs-built_in">cat</span> testout <br>This output should go to the testout file <br>$ <span class="hljs-built_in">cat</span> testerror <br>but this should go to the testerror file <br>$ <br><br></code></pre></td></tr></table></figure><h2 id="在脚本中重定向输入"><a href="#在脚本中重定向输入" class="headerlink" title="在脚本中重定向输入"></a>在脚本中重定向输入</h2><p>可以使用与脚本中重定向 STDOUT 和 STDERR 相同的方法来将 STDIN 从键盘重定向到其他位置。 exec 命令允许你将 STDIN 重定向到Linux系统上的文件中.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test12 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># redirecting file input </span><br><span class="hljs-comment"># 重定向输入，从文件testfile中获得输入，而不是STDIN</span><br><span class="hljs-built_in">exec</span> 0&lt; testfile <br>count=1 <br> <br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line <br><span class="hljs-keyword">do</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Line #<span class="hljs-variable">$count</span>: <span class="hljs-variable">$line</span>&quot;</span> <br>   count=$[ <span class="hljs-variable">$count</span> + 1 ] <br><span class="hljs-keyword">done</span> <br>$ ./test12 <br>Line <span class="hljs-comment">#1: This is the first line. </span><br>Line <span class="hljs-comment">#2: This is the second line. </span><br>Line <span class="hljs-comment">#3: This is the third line. </span><br></code></pre></td></tr></table></figure><h2 id="创建自己的重定向"><a href="#创建自己的重定向" class="headerlink" title="创建自己的重定向"></a>创建自己的重定向</h2><p>在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符。在shell中最多可以有9个打开的文件描述符。其他6个从 3 ~ 8 的文件描述符均可用作输入或输出重定向。可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。</p><h3 id="创建输出文件描述符"><a href="#创建输出文件描述符" class="headerlink" title="创建输出文件描述符"></a>创建输出文件描述符</h3><p>使用 exec 命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test13 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># using an alternative file descriptor </span><br><span class="hljs-comment"># 将文件描述符3 重定向到另一个文件</span><br><span class="hljs-built_in">exec</span> 3&gt;test13out <br> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This should display on the monitor&quot;</span> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;and this should be stored in the file&quot;</span> &gt;&amp;3 <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Then this should be back on the monitor&quot;</span> <br>$ ./test13 <br>This should display on the monitor <br>Then this should be back on the monitor <br>$ <span class="hljs-built_in">cat</span> test13out <br>and this should be stored <span class="hljs-keyword">in</span> the file <br>$ <br></code></pre></td></tr></table></figure><h3 id="重定向文件描述符"><a href="#重定向文件描述符" class="headerlink" title="重定向文件描述符"></a>重定向文件描述符</h3><p>如果要恢复已重定向的文件描述符，你可以分配另外一个文件描述符给标准文件描述符。这意味着你可以将 STDOUT 的原来位置重定向到另一个文件描述符，然后再利用该文件描述符重定向回 STDOUT。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test14 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># storing STDOUT, then coming back to it </span><br><span class="hljs-comment"># 将文件描述符 3 重定向到文件描述符1的当前位置，也就是STDOUT。这意味着任何发送给文件描述符3的输出都将出现在显示器上。</span><br><span class="hljs-built_in">exec</span> 3&gt;&amp;1 <br><span class="hljs-comment"># 将STDOUT重定向到文件，shell现在会将发送给STDOUT 的输出直接重定向到输出文件中。但是，文件描述符 3仍然指向STDOUT原来的位置，也就是显示器。如果此时将输出数据发送给文件描述符3，它仍然会出现在显示器上</span><br><span class="hljs-built_in">exec</span> 1&gt;test14out <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This should store in the output file&quot;</span> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;along with this line.&quot;</span> <br><span class="hljs-comment"># 在向 STDOUT （现在指向一个文件）发送一些输出之后，脚本将 STDOUT 重定向到文件描述符3的当前位置（现在仍然是显示器）。这意味着现在 STDOUT 又指向了它原来的位置：显示器。 </span><br><span class="hljs-built_in">exec</span> 1&gt;&amp;3 <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Now things should be back to normal&quot;</span> <br>$ <br>$ ./test14 <br>Now things should be back to normal <br>$ <span class="hljs-built_in">cat</span> test14out <br>This should store <span class="hljs-keyword">in</span> the output file <br>along with this line. <br>$ <br></code></pre></td></tr></table></figure><h3 id="创建输入文件描述符"><a href="#创建输入文件描述符" class="headerlink" title="创建输入文件描述符"></a>创建输入文件描述符</h3><p>可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前，先将 STDIN 文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将 STDIN 恢复到它原来的位置。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test15 <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># redirecting input file descriptors </span><br><br><span class="hljs-comment"># 文件描述符6用来保存 STDIN 的位置</span><br><span class="hljs-built_in">exec</span> 6&lt;&amp;0 <br><span class="hljs-comment"># 将 STDIN 重定向到一个文件,read 命令的所有输入都来自重定向后的 STDIN （也就是输入文件）。</span><br><span class="hljs-built_in">exec</span> 0&lt; testfile <br> <br>count=1 <br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line <br><span class="hljs-keyword">do</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Line #<span class="hljs-variable">$count</span>: <span class="hljs-variable">$line</span>&quot;</span> <br>   count=$[ <span class="hljs-variable">$count</span> + 1 ] <br><span class="hljs-keyword">done</span> <br><span class="hljs-comment"># 将 STDIN 重定向到文件描述符 6 ，从而将STDIN恢复到原先的位置。</span><br><span class="hljs-built_in">exec</span> 0&lt;&amp;6 <br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Are you done now? &quot;</span> answer <br><span class="hljs-keyword">case</span> <span class="hljs-variable">$answer</span> <span class="hljs-keyword">in</span> <br>Y|y) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Goodbye&quot;</span>;; <br>N|n) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Sorry, this is the end.&quot;</span>;; <br><span class="hljs-keyword">esac</span> <br>$ ./test15 <br>Line <span class="hljs-comment">#1: This is the first line. </span><br>Line <span class="hljs-comment">#2: This is the second line. </span><br>Line <span class="hljs-comment">#3: This is the third line. </span><br>Are you <span class="hljs-keyword">done</span> now? y <br>Goodbye <br></code></pre></td></tr></table></figure><h3 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h3><p>如果你创建了新的输入或输出文件描述符，shell会在脚本退出时自动关闭它们。然而在有些情况下，你需要在脚本结束前手动关闭文件描述符.</p><p>要关闭文件描述符，将它重定向到特殊符号 <code>&amp;-</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭文件描述符 3 ，不再在脚本中使用它</span><br><span class="hljs-built_in">exec</span> 3&gt;&amp;- <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> badtest <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># testing closing file descriptors </span><br><span class="hljs-built_in">exec</span> 3&gt; test17file <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is a test line of data&quot;</span> &gt;&amp;3 <br><span class="hljs-built_in">exec</span> 3&gt;&amp;- <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This won&#x27;t work&quot;</span> &gt;&amp;3 <br>$ ./badtest <br>./badtest: 3: Bad file descriptor <br>$ <br></code></pre></td></tr></table></figure><h2 id="列出打开的文件描述符"><a href="#列出打开的文件描述符" class="headerlink" title="列出打开的文件描述符"></a>列出打开的文件描述符</h2><p>lsof 命令会列出整个Linux系统打开的所有文件描述符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ /usr/sbin/lsof -a -p $$ -d 0,1,2 <br>COMMAND  PID USER   FD   TYPE DEVICE SIZE NODE NAME <br>bash    3344 rich    0u   CHR  136,0         2 /dev/pts/0 <br>bash    3344 rich    1u   CHR  136,0         2 /dev/pts/0 <br>bash    3344 rich    2u   CHR  136,0         2 /dev/pts/0 <br>------------------------------------------------------------------<br>-p 指定进程ID,PID<br>-d 指定要显示的文件描述符编号<br>-a 对两个选项结果进行AND运算<br>$$ 当前pid<br><br><span class="hljs-comment"># lsof的默认输出 </span><br>COMMAND  正在运行的命令名的前9个字符 <br>PID  进程的PID <br>USER  进程属主的登录名 <br>FD  文件描述符号以及访问类型（r代表读，w代表写，u代表读写） <br>TYPE  文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件） <br>DEVICE  设备的设备号（主设备号和从设备号）<br>SIZE  如果有的话，表示文件的大小 <br>NODE  本地文件的节点号 <br>NAME  文件名 <br><br>与STDIN、STDOUT和STDERR关联的文件类型是字符型。因为STDIN、STDOUT和STDERR文件描述符都指向终端，所以输出文件的名称就是终端的设备名。<br></code></pre></td></tr></table></figure><h2 id="阻止命令输出"><a href="#阻止命令输出" class="headerlink" title="阻止命令输出"></a>阻止命令输出</h2><p>可以将 <code>STDERR</code> 重定向到一个叫作null文件的特殊文件。null文件里什么都没有。shell输出到null文件的任何数据都不会保存，全部都被丢掉了。<br>在Linux系统上null文件的标准位置是<code>/dev/null</code>。你重定向到该位置的任何数据都会被丢掉，不会显示。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> -al &gt; /dev/null <br>$ <span class="hljs-built_in">cat</span> /dev/null <br>$ <br><span class="hljs-comment"># 避免错误消息</span><br>$ <span class="hljs-built_in">ls</span> -al badfile test16 2&gt; /dev/null <br>-rwxr--r--    1 rich     rich          135 Oct 29 19:57 test16* <br>$ <br><span class="hljs-comment"># 快速清除现有文件的数据,清除日志文件的常用方法</span><br>$ <span class="hljs-built_in">cat</span> /dev/null &gt; testfile <br>$ <span class="hljs-built_in">cat</span> testfile <br>$ 清除日志文件的一个常用方法<br></code></pre></td></tr></table></figure><h2 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h2><p>Linux系统有特殊的目录，专供临时文件使用。Linux使用<code>/tmp</code>目录来存放不需要永久保留的文件。大多数Linux发行版配置了系统在启动时自动删除<code>/tmp</code>目录的所有文件。系统上的任何用户账户都有权限在读写<code>/tmp</code>目录中的文件。有个特殊命令可以用来创建临时文件。 <code>mktemp </code>命令可以在<code>/tmp</code>目录中创建一个唯一的临时文件。shell会创建这个文件，但不用默认的<code> umask</code> 值。它会将文件的读和写权限分配给文件的属主，并将你设成文件的属主。</p><h3 id="创建本地临时文件"><a href="#创建本地临时文件" class="headerlink" title="创建本地临时文件"></a>创建本地临时文件</h3><p>默认情况下， <code>mktemp</code> 会在本地目录中创建一个文件。要用 <code>mktemp</code> 命令在本地目录中创建一个临时文件，你需要指定一个文件名模板。模板可以包含任意文本文件名，在文件名末尾加上6个 X </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mktemp</span> testing.XXXXXX <br>testing.1DRLuV <br><br><span class="hljs-comment"># shell脚本中保存文件名称</span><br>tempfile=$(<span class="hljs-built_in">mktemp</span> test.XXXXXX) <br></code></pre></td></tr></table></figure><h3 id="在-tmp-目录创建临时文件"><a href="#在-tmp-目录创建临时文件" class="headerlink" title="在&#x2F;tmp 目录创建临时文件"></a>在&#x2F;tmp 目录创建临时文件</h3><p> <code>mktemp</code> 命令使用<code>-t</code> 选项在系统的临时目录来创建临时文件。创建好后会返回用来创建临时文件的全路径，而不是只有文件名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mktemp</span> -t test.XXXXXX <br>/tmp/test.xG3374 <br>$ <span class="hljs-built_in">ls</span> -al /tmp/test* <br>-rw------- 1 rich rich 0 2014-10-29 18:41 /tmp/test.xG3374 <br>$ <br></code></pre></td></tr></table></figure><h3 id="创建临时目录"><a href="#创建临时目录" class="headerlink" title="创建临时目录"></a>创建临时目录</h3><p><code>mktemp</code> 命令-d 选项来创建一个临时目录而不是临时文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">tempdir=$(<span class="hljs-built_in">mktemp</span> -d dir.XXXXXX) <br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$tempdir</span> <br>tempfile1=$(<span class="hljs-built_in">mktemp</span> temp.XXXXXX) <br>tempfile2=$(<span class="hljs-built_in">mktemp</span> temp.XXXXXX) <br></code></pre></td></tr></table></figure><h2 id="记录消息-tee"><a href="#记录消息-tee" class="headerlink" title="记录消息 (tee)"></a>记录消息 (tee)</h2><p>如果需要将输出同时发送到显示器和日志文件，只要用特殊的 tee 命令就行。<br>tee 命令相当于管道的一个T型接头。它将从 STDIN 过来的数据同时发往两处。一处是STDOUT ，另一处是 tee 命令行所指定的文件名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tee</span> filename<br>-a 将数据追加到文件 <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 由于tee会重定向来自STDIN的数据，可以用它配合管道命令来重定向命令输出。 </span><br>$ <span class="hljs-built_in">date</span> | <span class="hljs-built_in">tee</span> testfile <br>Sun Oct 19 18:56:21 EDT 2014 <br>$ <span class="hljs-built_in">cat</span> testfile <br>Sun Oct 19 18:56:21 EDT 2014 <br>$ <br></code></pre></td></tr></table></figure><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell脚本(3)处理用户输入</title>
    <link href="/2018/02/21/shell-script-3-user-input/"/>
    <url>/2018/02/21/shell-script-3-user-input/</url>
    
    <content type="html"><![CDATA[<p>bash shell提供了一些不同的方法来从用户处获得数据，包括命令行参数(添加在命令后的数据)、命令行选项(可修改命令行为的单个字母)以及键盘输入</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><h3 id="读取参数"><a href="#读取参数" class="headerlink" title="读取参数"></a>读取参数</h3><p>bash shell会将一些称为位置参数(positional parameter)的特殊变量分配给输入到命令行中的所有参数位置参数变量是标准的数字:<code>$0</code>是程序名,<code>$1</code>是第一个参数,<code>$2</code> 是第二个参数,依次类推,直到第九个参数<code>$9</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test2.sh<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># testing two command line parameters</span><br><span class="hljs-comment"># </span><br>total=$[ <span class="hljs-variable">$1</span> * <span class="hljs-variable">$2</span> ]<br><span class="hljs-built_in">echo</span> The first parameter is <span class="hljs-variable">$1</span>.<br><span class="hljs-built_in">echo</span> The second parameter is <span class="hljs-variable">$2</span>.<br><span class="hljs-built_in">echo</span> The total value is <span class="hljs-variable">$total</span>.<br>$ <br>$ ./test2.sh 2 5<br>The first parameter is 2.<br>The second parameter is 5.<br>The total value is 10.<br></code></pre></td></tr></table></figure><p>每个参数都是用空格分隔的，要在参数值中包含空格，必须要用引号(单引号或双引号均可)<br>如果脚本需要的命令行参数不止9个，你仍然可以处理，但是需要稍微修改一下变量名。在第9个变量之后，你必须在变量数字周围加上花括号，比如<code>$&#123;10&#125;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test4.sh <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># handling lots of parameters </span><br><span class="hljs-comment"># </span><br>total=$[ <span class="hljs-variable">$&#123;10&#125;</span> * <span class="hljs-variable">$&#123;11&#125;</span> ] <br><span class="hljs-built_in">echo</span> The tenth parameter is <span class="hljs-variable">$&#123;10&#125;</span> <br><span class="hljs-built_in">echo</span> The eleventh parameter is <span class="hljs-variable">$&#123;11&#125;</span> <br><span class="hljs-built_in">echo</span> The total is <span class="hljs-variable">$total</span> <br>$  <br>$ ./test4.sh 1 2 3 4 5 6 7 8 9 10 11 12 <br>The tenth parameter is 10 <br>The eleventh parameter is 11 <br>The total is 110 <br>$ <br></code></pre></td></tr></table></figure><h3 id="读取脚本名"><a href="#读取脚本名" class="headerlink" title="读取脚本名"></a>读取脚本名</h3><p>用<code>$0</code>参数获取shell在命令行启动的脚本名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test5b.sh<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># Using basename with the $0 parameter</span><br><span class="hljs-comment"># </span><br>name=$(<span class="hljs-built_in">basename</span> <span class="hljs-variable">$0</span>) <span class="hljs-comment"># basename 命令会返回不包含路径的脚本名</span><br><span class="hljs-built_in">echo</span><br><span class="hljs-built_in">echo</span> The script name is: <span class="hljs-variable">$name</span><br><span class="hljs-comment"># </span><br><br>$ bash /home/Christine/test5b.sh <br>The script name is: test5b.sh <br>$ ./test5b.sh <br>The script name is: test5b.sh <br></code></pre></td></tr></table></figure><h3 id="测试参数"><a href="#测试参数" class="headerlink" title="测试参数"></a>测试参数</h3><p>在使用参数前一定要检查其中是否存在数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test7.sh <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># testing parameters before use </span><br><span class="hljs-comment"># </span><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]  <span class="hljs-comment"># -n测试来检查命令行参数 $1 中是否有数据</span><br><span class="hljs-keyword">then</span> <br>   <span class="hljs-built_in">echo</span> Hello <span class="hljs-variable">$1</span>, glad to meet you. <br><span class="hljs-keyword">else</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Sorry, you did not identify yourself. &quot;</span> <br><span class="hljs-keyword">fi</span> <br>$  <br></code></pre></td></tr></table></figure><h2 id="特殊参数变量"><a href="#特殊参数变量" class="headerlink" title="特殊参数变量"></a>特殊参数变量</h2><h3 id="参数统计"><a href="#参数统计" class="headerlink" title="参数统计"></a>参数统计</h3><p>特殊变量<code>$#</code>含有脚本运行时携带的命令行参数的个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test8.sh <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># getting the number of parameters </span><br><span class="hljs-comment"># </span><br><span class="hljs-built_in">echo</span> There were <span class="hljs-variable">$#</span> parameters supplied. <br>$  <br>$ ./test8.sh <br>There were 0 parameters supplied. <br>$  <br>$ ./test8.sh 1 2 3 4 5 <br>There were 5 parameters supplied. <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取最后一个参数 $&#123;!#&#125;</span><br><br>$ <span class="hljs-built_in">cat</span> test10.sh<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># Grabbing the last parameter</span><br><span class="hljs-comment"># </span><br>params=<span class="hljs-variable">$#</span><br><span class="hljs-built_in">echo</span><br><span class="hljs-built_in">echo</span> The last parameter is <span class="hljs-variable">$params</span><br><span class="hljs-built_in">echo</span> The last parameter is <span class="hljs-variable">$&#123;!#&#125;</span><br><span class="hljs-built_in">echo</span><br><span class="hljs-comment"># </span><br>$ bash test10.sh 1 2 3 4 5 <br>The last parameter is 5 <br>The last parameter is 5 <br><br>$ bash test10.sh <br>The last parameter is 0 <br>The last parameter is test10.sh <br><br><span class="hljs-comment"># 注意，当命令行上没有任何参数时，$#的值为 0 ，params 变量的值也一样，但$&#123;!#&#125;变量会返回命令行用到的脚本名</span><br></code></pre></td></tr></table></figure><h3 id="抓取所有的数据"><a href="#抓取所有的数据" class="headerlink" title="抓取所有的数据"></a>抓取所有的数据</h3><p><code>$*</code>和 <code>$@</code>变量可以用来轻松访问所有的参数。这两个变量都能够在单个变量中存储所有的命令行参数</p><p><code>$*</code> 变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的一个参数值。基本上<code> $*</code> 变量会将这些参数视为一个整体，而不是多个个体。</p><p><code>$@</code> 变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样你就能够遍历所有的参数值，得到每个参数。这通常通过 for 命令完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test12.sh<br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-comment"># testing $* and $@</span><br><span class="hljs-comment">#</span><br><span class="hljs-built_in">echo</span><br>count=1<br><span class="hljs-comment">#</span><br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;$*&quot;</span><br><span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\$* Parameter #<span class="hljs-variable">$count</span> = <span class="hljs-variable">$param</span>&quot;</span><br>  count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br><span class="hljs-comment">#</span><br><span class="hljs-built_in">echo</span><br>count=1<br><span class="hljs-comment">#</span><br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br><span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\$@ Parameter #<span class="hljs-variable">$count</span> = <span class="hljs-variable">$param</span>&quot;</span><br>  count=$[ <span class="hljs-variable">$count</span> + 1 ]<br><span class="hljs-keyword">done</span><br>$ <br>$ ./test12.sh rich barbara katie jessica<br> <br>$* Parameter <span class="hljs-comment">#1 = rich barbara katie jessica</span><br> <br><span class="hljs-variable">$@</span> Parameter <span class="hljs-comment">#1 = rich</span><br><span class="hljs-variable">$@</span> Parameter <span class="hljs-comment">#2 = barbara</span><br><span class="hljs-variable">$@</span> Parameter <span class="hljs-comment">#3 = katie</span><br><span class="hljs-variable">$@</span> Parameter <span class="hljs-comment">#4 = jessica</span><br>$<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell脚本(2)结构化命令</title>
    <link href="/2018/02/20/shell-script-2-structed-command/"/>
    <url>/2018/02/20/shell-script-2-structed-command/</url>
    
    <content type="html"><![CDATA[<p>逻辑流程控制通常称为结构化命令(structured command)</p><h2 id="使用-if-then-语句"><a href="#使用-if-then-语句" class="headerlink" title="使用 if-then 语句"></a>使用 if-then 语句</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span><br>    commands<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>bash shell的 if 语句会运行 if 后面的那个命令。如果该命令的退出状态码是0（该命令成功运行），位于 then 部分的命令就会被执行,如果该命令的退出状态码是其他值， then部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test1.sh<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># testing the if statement</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">pwd</span><br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;It worked&quot;</span><br><span class="hljs-keyword">fi</span><br>$<br></code></pre></td></tr></table></figure><p>if-then 语句的另一种形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span>; <span class="hljs-keyword">then</span><br>commands <br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h2 id="if-then-else-语句"><a href="#if-then-else-语句" class="headerlink" title="if-then-else 语句"></a>if-then-else 语句</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">then</span><br>  commands<br><span class="hljs-keyword">else</span><br>  commands<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h2 id="嵌套-if"><a href="#嵌套-if" class="headerlink" title="嵌套 if"></a>嵌套 if</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> command1 <br><span class="hljs-keyword">then</span> <br>    <span class="hljs-built_in">command</span> <span class="hljs-built_in">set</span> 1 <br><span class="hljs-keyword">elif</span> command2 <br><span class="hljs-keyword">then</span> <br>   <span class="hljs-built_in">command</span> <span class="hljs-built_in">set</span> 2 <br><span class="hljs-keyword">elif</span> command3 <br><span class="hljs-keyword">then</span> <br>   <span class="hljs-built_in">command</span> <span class="hljs-built_in">set</span> 3 <br><span class="hljs-keyword">elif</span> command4 <br><span class="hljs-keyword">then</span> <br>   <span class="hljs-built_in">command</span> <span class="hljs-built_in">set</span> 4 <br><span class="hljs-keyword">fi</span> <br></code></pre></td></tr></table></figure><h2 id="test-命令"><a href="#test-命令" class="headerlink" title="test 命令"></a>test 命令</h2><p>test 命令提供了在 if-then 语句中测试不同条件的途径,如果 test 命令中列出的条件成立,test 命令就会退出并返回退出状态码0。<br>test 命令的格式非常简单。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span> condition<br>--------------------------------<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> condition<br><span class="hljs-keyword">then</span><br>  commands<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p> 判断内容是否为空</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test6.sh <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># Testing the test command </span><br><span class="hljs-comment"># </span><br>my_variable=<span class="hljs-string">&quot;&quot;</span> <br><span class="hljs-comment"># </span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> <span class="hljs-variable">$my_variable</span><br><span class="hljs-keyword">then</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The <span class="hljs-variable">$my_variable</span> expression returns a True&quot;</span> <br><span class="hljs-comment"># </span><br><span class="hljs-keyword">else</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The <span class="hljs-variable">$my_variable</span> expression returns a False&quot;</span> <br><span class="hljs-keyword">fi</span> <br>$ <br>$ ./test6.sh <br>The  expression returns a False <br>$ <br></code></pre></td></tr></table></figure><p>bash shell提供了另一种条件测试方法，无需在 if-then 语句中声明 test 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ condition ]<br><span class="hljs-keyword">then</span><br>  commands<br><span class="hljs-keyword">fi</span><br><span class="hljs-comment"># 方括号定义了测试条件。注意，第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。</span><br></code></pre></td></tr></table></figure><p>test 命令可以判断三类条件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">数值比较<br>字符串比较<br>文件比较<br></code></pre></td></tr></table></figure><h3 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h3><p>test命令的数值比较功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">n1 -eq n2  检查n1是否与n2相等<br>n1 -ge n2  检查n1是否大于或等于n2 <br>n1 -gt n2  检查n1是否大于n2 <br>n1 -le n2  检查n1是否小于或等于n2 <br>n1 -lt n2  检查n1是否小于n2 <br>n1 -ne n2  检查n1是否不等于n2 <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> numeric_test.sh<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># Using numeric test evaluations</span><br><span class="hljs-comment"># </span><br>value1=10<br>value2=11<br><span class="hljs-comment"># </span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$value1</span> -gt 5 ] <span class="hljs-comment"># 测试变量 value1 的值是否大于 5</span><br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The test value <span class="hljs-variable">$value1</span> is greater than 5&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-comment"># </span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$value1</span> -eq <span class="hljs-variable">$value2</span> ] <span class="hljs-comment"># 测试变量 value1 的值是否和变量 value2 的值相等</span><br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The values are equal&quot;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The values are different&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-comment"># </span><br>$<br></code></pre></td></tr></table></figure><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>字符串比较测试 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">str1 = str2   检查str1是否和str2相同<br>str1 != str2  检查str1是否和str2不同<br>str1 &lt; str2   检查str1是否比str2小<br>str1 &gt; str2   检查str1是否比str2大<br>-n str1       检查str1的长度是否非0<br>-z str1       检查str1的长度是否为0<br><br></code></pre></td></tr></table></figure><h4 id="1-字符串相等性"><a href="#1-字符串相等性" class="headerlink" title="1.字符串相等性"></a>1.字符串相等性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test7.sh <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># testing string equality </span><br>testuser=rich <br><span class="hljs-comment"># </span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$USER</span> = <span class="hljs-variable">$testuser</span> ] <br><span class="hljs-keyword">then</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Welcome <span class="hljs-variable">$testuser</span>&quot;</span> <br><span class="hljs-keyword">fi</span> <br>$  <br>$ ./test7.sh <br>Welcome rich <br>$ <br></code></pre></td></tr></table></figure><p>记住，在比较字符串的相等性时，比较测试会将所有的标点和大小写情况都考虑在内。</p><h4 id="2-字符串顺序"><a href="#2-字符串顺序" class="headerlink" title="2.字符串顺序"></a>2.字符串顺序</h4><p>大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名；<br>大于和小于顺序和 sort 命令所采用的不同。</p><p>比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果。 sort命令使用的是系统的本地化语言设置中定义的排序顺序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test9.sh<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># mis-using string comparisons</span><br><span class="hljs-comment"># </span><br>val1=baseball<br>val2=hockey<br><span class="hljs-comment"># </span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$val1</span> \&gt; <span class="hljs-variable">$val2</span> ]<br>  <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$val1</span> is greater than <span class="hljs-variable">$val2</span>&quot;</span><br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$val1</span> is less than <span class="hljs-variable">$val2</span>&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>注意,test 命令和测试表达式使用标准的数学比较符号来表示字符串比较，而用文本代码来表示数值比较</p><h4 id="3-字符串大小"><a href="#3-字符串大小" class="headerlink" title="3.字符串大小"></a>3.字符串大小</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test10.sh <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-comment"># testing string length </span><br>val1=testing <br>val2=<span class="hljs-string">&#x27;&#x27;</span> <br><span class="hljs-comment"># </span><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-variable">$val1</span> ] <br><span class="hljs-keyword">then</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The string &#x27;<span class="hljs-variable">$val1</span>&#x27; is not empty&quot;</span> <br><span class="hljs-keyword">else</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The string &#x27;<span class="hljs-variable">$val1</span>&#x27; is empty&quot;</span> <br><span class="hljs-keyword">fi</span> <br><span class="hljs-comment"># </span><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-variable">$val2</span> ] <br><span class="hljs-keyword">then</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The string &#x27;<span class="hljs-variable">$val2</span>&#x27; is empty&quot;</span> <br><span class="hljs-keyword">else</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The string &#x27;<span class="hljs-variable">$val2</span>&#x27; is not empty&quot;</span> <br><span class="hljs-keyword">fi</span> <br><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-variable">$val3</span> ] <span class="hljs-comment"># 未被定义过，长度为0</span><br><span class="hljs-keyword">then</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The string &#x27;<span class="hljs-variable">$val3</span>&#x27; is empty&quot;</span> <br><span class="hljs-keyword">else</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The string &#x27;<span class="hljs-variable">$val3</span>&#x27; is not empty&quot;</span> <br><span class="hljs-keyword">fi</span> <br>$  <br>$ ./test10.sh <br>The string <span class="hljs-string">&#x27;testing&#x27;</span> is not empty <br>The string <span class="hljs-string">&#x27;&#x27;</span> is empty <br>The string <span class="hljs-string">&#x27;&#x27;</span> is empty <br>$ <br></code></pre></td></tr></table></figure><h3 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h3><p>文件比较是shell编程中最为强大、也是用得最多的比较形式。它允许你测试Linux文件系统上文件和目录的状态。</p><p>test命令的文件比较功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">-d file  检查file是否存在并是一个目录<br>-e file  检查file是否存在<br>-f file  检查file是否存在并是一个文件<br>-r file  检查file是否存在并可读<br>-s file  检查file是否存在并非空<br>-w file  检查file是否存在并可写<br>-x file  检查file是否存在并可执行<br>-O file  检查file是否存在并属当前用户所有<br>-G file  检查file是否存在并且默认组与当前用户相同<br>file1 -nt file2  检查file1是否比file2新<br>file1 -ot file2  检查file1是否比file2旧<br></code></pre></td></tr></table></figure><h4 id="1-检查目录"><a href="#1-检查目录" class="headerlink" title="1.检查目录"></a>1.检查目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test11.sh<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># Look before you leap</span><br><span class="hljs-comment"># </span><br>jump_directory=/home/arthur<br><span class="hljs-comment"># </span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-variable">$jump_directory</span> ]<br><span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The <span class="hljs-variable">$jump_directory</span> directory exists&quot;</span><br>  <span class="hljs-built_in">cd</span> <span class="hljs-variable">$jump_directory</span><br>  <span class="hljs-built_in">ls</span><br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The <span class="hljs-variable">$jump_directory</span> directory does not exist&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-comment"># $</span><br>$ ./test11.sh<br>The /home/arthur directory does not exist<br>$<br></code></pre></td></tr></table></figure><h2 id="复合条件测试"><a href="#复合条件测试" class="headerlink" title="复合条件测试"></a>复合条件测试</h2><p>if-then 语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ condition1 ] &amp;&amp; [ condition2 ]<br>[ condition1 ] || [ condition2 ] <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test22.sh <br><span class="hljs-comment">#!/bin/bash </span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-variable">$HOME</span> ] &amp;&amp; [ -w <span class="hljs-variable">$HOME</span>/testing ] <br><span class="hljs-keyword">then</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The file exists and you can write to it&quot;</span> <br><span class="hljs-keyword">else</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;I cannot write to the file&quot;</span> <br><span class="hljs-keyword">fi</span> <br></code></pre></td></tr></table></figure><h2 id="if-then-的高级特性"><a href="#if-then-的高级特性" class="headerlink" title="if-then 的高级特性"></a>if-then 的高级特性</h2><p>bash shell提供了两项可在 if-then 语句中使用的高级特性：</p><blockquote><p>用于数学表达式的双括号</p></blockquote><blockquote><p> 用于高级字符串处理功能的双方括号</p></blockquote><h3 id="使用双括号"><a href="#使用双括号" class="headerlink" title="使用双括号"></a>使用双括号</h3><p>双括号命令允许你在比较过程中使用高级数学表达式。 test 命令只能在比较中使用简单的<br>算术操作,双括号命令的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(( expression ))<br><br></code></pre></td></tr></table></figure><p>双括号命令符号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">val++  后增<br>val--  后减<br>++val  先增<br>--val  先减<br>!      逻辑求反<br>~      位求反<br>**     幂运算<br>&lt;&lt;     左位移<br>&gt;&gt;     右位移<br>&amp;      位布尔和<br>|      位布尔或<br>&amp;&amp;     逻辑和<br>||     逻辑或<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test23.sh<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># using double parenthesis</span><br><span class="hljs-comment">#</span><br>val1=10<br><span class="hljs-comment"># </span><br><span class="hljs-keyword">if</span> (( <span class="hljs-variable">$val1</span> ** <span class="hljs-number">2</span> &gt; <span class="hljs-number">90</span> )) <span class="hljs-comment"># 不需要将双括号中表达式里的大于号转义</span><br><span class="hljs-keyword">then</span><br>  (( val2 = <span class="hljs-variable">$val1</span> ** <span class="hljs-number">2</span> ))<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The square of <span class="hljs-variable">$val1</span> is <span class="hljs-variable">$val2</span>&quot;</span><br><span class="hljs-keyword">fi</span><br>$ <br>$ ./test23.sh<br>The square of 10 is 100<br>$<br></code></pre></td></tr></table></figure><h3 id="使用双方括号"><a href="#使用双方括号" class="headerlink" title="使用双方括号"></a>使用双方括号</h3><p>双方括号命令提供了针对字符串比较的高级特性。双方括号命令的格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[[ expression ]]<br></code></pre></td></tr></table></figure><p>双方括号里的 expression 使用了 test 命令中采用的标准字符串比较。但它提供了 test 命令未提供的另一个特性——模式匹配（pattern matching）。</p><p>在模式匹配中，可以定义一个正则表达式来匹配字符串值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test24.sh<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># using pattern matching</span><br><span class="hljs-comment"># </span><br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$USER</span> == r* ]]<br><span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello <span class="hljs-variable">$USER</span>&quot;</span><br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Sorry, I do not know you&quot;</span><br><span class="hljs-keyword">fi</span><br>$ <br>$ ./test24.sh<br>Hello rich<br>$<br></code></pre></td></tr></table></figure><h2 id="case-命令"><a href="#case-命令" class="headerlink" title="case 命令"></a>case 命令</h2><p>case 命令会采用列表格式来检查单个变量的多个值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">case</span> variable <span class="hljs-keyword">in</span><br>pattern1 | pattern2) commands1;;<br>pattern3) commands2;;<br>*) default commands;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure><p>case 命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的，那么shell会执行为该模式指定的命令。可以通过竖线操作符在一行中分隔出多个模式模式。星号会捕获所有与已知模式不匹配的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test26.sh<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># using the case command</span><br><span class="hljs-comment"># </span><br><span class="hljs-keyword">case</span> <span class="hljs-variable">$USER</span> <span class="hljs-keyword">in</span><br>rich | barbara)<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Welcome, <span class="hljs-variable">$USER</span>&quot;</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Please enjoy your visit&quot;</span>;;<br>testing)<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Special testing account&quot;</span>;;<br>jessica)<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Do not forget to log off when you&#x27;re done&quot;</span>;;<br>*)<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Sorry, you are not allowed here&quot;</span>;;<br><span class="hljs-keyword">esac</span><br>$ <br>$ ./test26.sh<br>Welcome, rich<br>Please enjoy your visit<br>$<br></code></pre></td></tr></table></figure><h2 id="for-命令"><a href="#for-命令" class="headerlink" title="for 命令"></a>for 命令</h2><p>bash shell提供了 for 命令，允许你创建一个遍历一系列值的循环。每次迭代都使用其中一个值来执行已定义好的一组命令。下面是bash shell中 for 命令的基本格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> list<br><span class="hljs-keyword">do</span><br>  commands<br><span class="hljs-keyword">done</span><br>---------------------------<br><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> list; <span class="hljs-keyword">do</span><br>  commands<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h3 id="读取列表中的值"><a href="#读取列表中的值" class="headerlink" title="读取列表中的值"></a>读取列表中的值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test1<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># basic for command</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span> <span class="hljs-keyword">in</span> Alabama Alaska <br><span class="hljs-keyword">do</span><br>   <span class="hljs-built_in">echo</span> The next state is <span class="hljs-variable">$test</span><br><span class="hljs-keyword">done</span><br>$ ./test1<br>The next state is Alabama<br>The next state is Alaska<br>$<br></code></pre></td></tr></table></figure><h3 id="读取列表中的复杂值"><a href="#读取列表中的复杂值" class="headerlink" title="读取列表中的复杂值"></a>读取列表中的复杂值</h3><p>使用转义字符（反斜线）来将单引号转义；<br>使用双引号来定义用到单引号的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test2<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># another example of how not to use the for command</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span> <span class="hljs-keyword">in</span> I don\&#x27;t know <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;this&#x27;ll&quot;</span> work<br><span class="hljs-keyword">do</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;word:<span class="hljs-variable">$test</span>&quot;</span><br><span class="hljs-keyword">done</span><br>$ ./test2<br>word:I<br>word:don<span class="hljs-string">&#x27;t</span><br><span class="hljs-string">word:know</span><br><span class="hljs-string">word:if</span><br><span class="hljs-string">word:this&#x27;</span>ll<br>word:work<br>$<br></code></pre></td></tr></table></figure><p>for 命令用<code>空格</code>来划分列表中的每个值。如果在单独的数据值中有空格，就必须用双引号将这些值圈起来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test3<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># an example of how to properly define values</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span> <span class="hljs-keyword">in</span> Nevada <span class="hljs-string">&quot;New Hampshire&quot;</span> <span class="hljs-string">&quot;New Mexico&quot;</span> <span class="hljs-string">&quot;New York&quot;</span><br><span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Now going to <span class="hljs-variable">$test</span>&quot;</span><br><span class="hljs-keyword">done</span><br>$ ./test3<br>Now going to Nevada<br>Now going to New Hampshire<br>Now going to New Mexico<br>Now going to New York<br>$<br></code></pre></td></tr></table></figure><h3 id="从变量读取列表"><a href="#从变量读取列表" class="headerlink" title="从变量读取列表"></a>从变量读取列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test4<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># using a variable to hold the list</span><br>list=<span class="hljs-string">&quot;Alabama Alaska Arizona&quot;</span><br>list=<span class="hljs-variable">$list</span><span class="hljs-string">&quot; Connecticut&quot;</span> <span class="hljs-comment"># 添加文本</span><br><span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> <span class="hljs-variable">$list</span><br><span class="hljs-keyword">do</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Have you ever visited <span class="hljs-variable">$state</span>?&quot;</span><br><span class="hljs-keyword">done</span><br>$ ./test4<br>Have you ever visited Alabama?<br>Have you ever visited Alaska?<br>Have you ever visited Arizona?<br>Have you ever visited Connecticut?<br>$<br></code></pre></td></tr></table></figure><p>添加&#x2F;拼接文本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$var</span>=<span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-variable">$var</span>=<span class="hljs-variable">$var</span><span class="hljs-string">&quot; world!&quot;</span><br></code></pre></td></tr></table></figure><h3 id="更改字段分隔符"><a href="#更改字段分隔符" class="headerlink" title="更改字段分隔符"></a>更改字段分隔符</h3><p>IFS(internal field separator,内部字段分隔符) 环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字符当作字段分隔符：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">空格<br>制表符<br>换行符<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test5b<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># reading values from a file</span><br>file=<span class="hljs-string">&quot;states&quot;</span><br><span class="hljs-comment"># 可以在shell脚本中临时更改 IFS 环境变量的值来限制被bash shell当作字段分隔符的字符</span><br><span class="hljs-comment">#告诉bash shell在数据值中忽略空格和制表符</span><br>IFS=$<span class="hljs-string">&#x27;\n&#x27;</span><br> <span class="hljs-comment"># 命令替换$() 来执行任何能产生输出的命令，然后在 for 命令中使用该命令的输出</span><br><span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">cat</span> <span class="hljs-variable">$file</span>)<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Visit beautiful <span class="hljs-variable">$state</span>&quot;</span><br><span class="hljs-keyword">done</span><br>$ ./test5b<br>Visit beautiful Alabama<br>Visit beautiful North Carolina<br>$<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 还原IFS方法</span><br> 在处理代码量较大的脚本时，可能在一个地方需要修改 IFS 的值，然后忽略这次修改，在脚本的其他地方继续沿用 IFS 的默认值。一个可参考的安全实践是在改变 IFS 之前保存原来的 IFS 值，之后再恢复它。 <br>这种技术可以这样实现： <br>IFS.OLD=<span class="hljs-variable">$IFS</span> <br>IFS=$<span class="hljs-string">&#x27;\n&#x27;</span> <br>&lt;在代码中使用新的IFS值&gt; <br>IFS=<span class="hljs-variable">$IFS</span>.OLD <br>这就保证了在脚本的后续操作中使用的是 IFS 的默认值。 <br></code></pre></td></tr></table></figure><p>还有其他一些 IFS 环境变量的绝妙用法。假定你要遍历一个文件中用冒号分隔的值（比如在&#x2F;etc&#x2F;passwd文件中）。你要做的就是将 IFS 的值设为冒号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">IFS=:<br></code></pre></td></tr></table></figure><p>如果要指定多个 IFS 字符，只要将它们在赋值行串起来就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">IFS=$<span class="hljs-string">&#x27;\n&#x27;</span>:;<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。如何使用 IFS 字符解析数据没有任何限制</p><h3 id="用通配符读取目录"><a href="#用通配符读取目录" class="headerlink" title="用通配符读取目录"></a>用通配符读取目录</h3><p>可以用 for 命令来自动遍历目录中的文件。进行此操作时，必须在文件名或路径名中使用通配符。它会强制shell使用文件扩展匹配。文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test6<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># iterate through all the files in a directory</span><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> /home/rich/test/*<br><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> ] <span class="hljs-comment">#路径可能包含空格，使用双引号括起来</span><br>    <span class="hljs-keyword">then</span><br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a directory&quot;</span><br>    <span class="hljs-keyword">elif</span> [ -f <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> ]<br>    <span class="hljs-keyword">then</span><br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a file&quot;</span><br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br>$ ./test6<br>/home/rich/test/dir1 is a directory<br>/home/rich/test/myprog.c is a file<br>/home/rich/test/myprog is a file<br></code></pre></td></tr></table></figure><h2 id="C-语言风格的-for-命令"><a href="#C-语言风格的-for-命令" class="headerlink" title="C 语言风格的 for 命令"></a>C 语言风格的 for 命令</h2><p>bash中C语言风格的 for 循环的基本格式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> (( variable assignment ; condition ; iteration process ))<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test8<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># testing the C-style for loop</span><br><span class="hljs-keyword">for</span> (( i=<span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ ))<br><span class="hljs-keyword">do</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The next number is <span class="hljs-variable">$i</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>使用多个变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># multiple variables</span><br><span class="hljs-keyword">for</span> (( a=<span class="hljs-number">1</span>, b=<span class="hljs-number">10</span>; a &lt;= <span class="hljs-number">10</span>; a++, b-- ))<br><span class="hljs-keyword">do</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> - <span class="hljs-variable">$b</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h2 id="while命令"><a href="#while命令" class="headerlink" title="while命令"></a>while命令</h2><p>while 命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码 0 。它会在每次迭代的一开始测试 test 命令。在 test 命令返回非零退出状态码时， while 命令会停止执行那组命令。while 命令的格式是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">test</span> <span class="hljs-built_in">command</span><br><span class="hljs-keyword">do</span><br>  other  commands<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test10<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># while command test</span><br>var1=10<br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$var1</span> -gt 0 ]<br><span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var1</span><br>  var1=$[ <span class="hljs-variable">$var1</span> - 1 ]<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>while 命令允许你在 while 语句行定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环</p><h2 id="until-命令"><a href="#until-命令" class="headerlink" title="until 命令"></a>until 命令</h2><p>until 命令和 while 命令工作的方式完全相反。until 命令要求你指定一个通常返回非零退出状态码的测试命令。只有测试命令的退出状态码不为 0 ，bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码 0 ，循环就结束了。until 命令的格式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">until</span> <span class="hljs-built_in">test</span> commands<br><span class="hljs-keyword">do</span><br>  other commands<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test12<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># using the until command</span><br>var1=100<br><span class="hljs-keyword">until</span> [ <span class="hljs-variable">$var1</span> -eq 0 ]<br><span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var1</span><br>  var1=$[ <span class="hljs-variable">$var1</span> - 25 ]<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h2 id="循环处理文件数据"><a href="#循环处理文件数据" class="headerlink" title="循环处理文件数据"></a>循环处理文件数据</h2><p>通常必须遍历存储在文件中的数据。这要求结合已经讲过的两种技术：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">使用嵌套循环<br>修改 <span class="hljs-built_in">IFS</span> 环境变量<br></code></pre></td></tr></table></figure><p>这个脚本使用了两个不同的 IFS 值来解析数据。第一个 IFS 值解析出<code>/etc/passwd</code>文件中的单独的行。内部 for 循环接着将 IFS 的值修改为冒号，允许你从<code>/etc/passwd</code>的行中解析出单独的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># changing the IFS value</span><br>IFS.OLD=<span class="hljs-variable">$IFS</span><br>IFS=$<span class="hljs-string">&#x27;\n&#x27;</span><br><span class="hljs-keyword">for</span> entry <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">cat</span> /etc/passwd)<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Values in <span class="hljs-variable">$entry</span> –&quot;</span><br>    IFS=:<br>    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-variable">$entry</span><br>    <span class="hljs-keyword">do</span><br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$value</span>&quot;</span><br>    <span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br>$<br></code></pre></td></tr></table></figure><h2 id="控制循环"><a href="#控制循环" class="headerlink" title="控制循环"></a>控制循环</h2><p>有两个命令能帮我们控制循环内部的情况,<code>break</code>命令和<code>continue</code>命令。</p><h3 id="break命令"><a href="#break命令" class="headerlink" title="break命令"></a>break命令</h3><p>用 break 命令来退出任意类型的循环，包括while 和 until 循环。</p><p>有时你在内部循环，但需要停止外部循环。 break 命令接受单个命令行参数值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">break</span> n<br></code></pre></td></tr></table></figure><p>其中 n 指定了要跳出的循环层级。默认情况下， n 为 1 ，表明跳出的是当前的循环。如果你将n 设为 2 ， break 命令就会停止下一级的外部循环。</p><h3 id="continue-命令"><a href="#continue-命令" class="headerlink" title="continue 命令"></a>continue 命令</h3><p>continue 命令可以提前中止某次循环中的命令，但并不会完全终止整个循环。可以在循环内部设置shell不执行命令的条件。</p><p>continue 命令也允许通过命令行参数指定要继续执行哪一级循环：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">continue</span> n<br></code></pre></td></tr></table></figure><p>其中 n 定义了要继续的循环层级。</p><h2 id="处理循环的输出"><a href="#处理循环的输出" class="headerlink" title="处理循环的输出"></a>处理循环的输出</h2><p>在shell脚本中，你可以对循环的输出使用管道或进行重定向,可以通过在 done 命令之后添加一个处理命令来实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> /home/rich/*<br><span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> ]<br>  <span class="hljs-keyword">then</span><br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a directory&quot;</span><br>  <span class="hljs-keyword">elif</span><br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file</span> is a file&quot;</span><br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span> &gt; output.txt<br><span class="hljs-comment"># shell会将 for 命令的结果重定向到文件output.txt中，而不是显示在屏幕上</span><br><span class="hljs-comment"># 这种方法同样适用于将循环的结果管接给另一个命令</span><br><span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;North Dakota&quot;</span> Connecticut Illinois Alabama Tennessee <br><span class="hljs-keyword">do</span> <br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$state</span> is the next place to go&quot;</span> <br><span class="hljs-keyword">done</span> | <span class="hljs-built_in">sort</span> <br><span class="hljs-comment"># 。 for 命令的输出传给了 sort 命令，该命令会改变 for 命令输出结果的顺序</span><br></code></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="查找可执行文件"><a href="#查找可执行文件" class="headerlink" title="查找可执行文件"></a>查找可执行文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test25<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># finding files in the PATH</span><br>IFS=:<br><span class="hljs-keyword">for</span> folder <span class="hljs-keyword">in</span> <span class="hljs-variable">$PATH</span> <span class="hljs-comment"># 对环境变量 PATH 中的目录进行迭代</span><br><span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$folder</span>:&quot;</span><br>  <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-variable">$folder</span>/* <span class="hljs-comment"># 迭代特定目录中的所有文件</span><br>  <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> [ -x <span class="hljs-variable">$file</span> ] <span class="hljs-comment"># 检查各个文件是否具有可执行权限</span><br>    <span class="hljs-keyword">then</span><br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;  <span class="hljs-variable">$file</span>&quot;</span><br>    <span class="hljs-keyword">fi</span><br>  <span class="hljs-keyword">done</span><br><span class="hljs-keyword">done</span><br>$<br></code></pre></td></tr></table></figure><h3 id="创建多个用户账户"><a href="#创建多个用户账户" class="headerlink" title="创建多个用户账户"></a>创建多个用户账户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test26<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># process new user accounts</span><br>input=<span class="hljs-string">&quot;users.csv&quot;</span><br><span class="hljs-keyword">while</span> IFS=<span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-built_in">read</span> -r userid name<br><span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;adding <span class="hljs-variable">$userid</span>&quot;</span><br>  useradd -c <span class="hljs-string">&quot;<span class="hljs-variable">$name</span>&quot;</span> -m <span class="hljs-variable">$userid</span><br><span class="hljs-keyword">done</span> &lt; <span class="hljs-string">&quot;<span class="hljs-variable">$input</span>&quot;</span><br>$<br><span class="hljs-variable">$input</span> 变量指向数据文件，并且该变量被作为 <span class="hljs-keyword">while</span> 命令的重定向数据。<br></code></pre></td></tr></table></figure><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell学习(1)构建基本脚本</title>
    <link href="/2018/02/19/shell-script-1-basic-script/"/>
    <url>/2018/02/19/shell-script-1-basic-script/</url>
    
    <content type="html"><![CDATA[<h2 id="使用多个命令"><a href="#使用多个命令" class="headerlink" title="使用多个命令"></a>使用多个命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用分号分隔多个命令</span><br>$ <span class="hljs-built_in">date</span> ; <span class="hljs-built_in">who</span> <br></code></pre></td></tr></table></figure><h2 id="基本shell脚本文件"><a href="#基本shell脚本文件" class="headerlink" title="基本shell脚本文件"></a>基本shell脚本文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># This script displays the date and who&#x27;s logged on</span><br><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;The time and date are: &quot;</span> <span class="hljs-comment">#把文本字符串和命令输出显示在同一行</span><br><span class="hljs-built_in">date</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Let&#x27;s see who&#x27;s logged into the system:&quot;</span><br><span class="hljs-built_in">who</span><br>$<br><span class="hljs-comment"># 运行脚本文件</span><br>$ test1 <br>bash: test1: <span class="hljs-built_in">command</span> not found <br>PATH 环境变量中没有找到命令，需要通过一下两种方式运行脚本:<br>1.将shell脚本文件所处的目录添加到 PATH 环境变量中； <br>2.在提示符中用绝对或相对文件路径来引用shell脚本文件。<br>$ ./test1 <br></code></pre></td></tr></table></figure><h2 id="显示消息"><a href="#显示消息" class="headerlink" title="显示消息"></a>显示消息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> Hello World<br><span class="hljs-comment"># 默认情况不需要引号，单双引号混用时才需要引号</span><br>-n 不换行<br></code></pre></td></tr></table></figure><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>shell维护着一组环境变量，用来记录特定的系统信息。比如系统的名称、登录到系统上的用户名、用户的系统ID（也称为UID）、用户的默认主目录以及shell查找程序的搜索路径。通过set命令查看当前环境变量列表。</p><p>在环境变量名称之前加上美元符($) 来使用这些环境变量,并且可以再双引号中使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;User info for userid: <span class="hljs-variable">$USER</span>&quot;</span><br><span class="hljs-built_in">echo</span> UID: <span class="hljs-variable">$UID</span><br><span class="hljs-built_in">echo</span> HOME: <span class="hljs-variable">$HOME</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;variable&#125;</span> <span class="hljs-comment">#变量名两侧额外的花括号通常用来帮助识别美元符后的变量名</span><br></code></pre></td></tr></table></figure><p>反斜线允许shell脚本将美元符解读为实际的美元符，而不是变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The cost of the item is \$15&quot;</span><br>The cost of the item is <span class="hljs-variable">$15</span><br></code></pre></td></tr></table></figure><h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>shell脚本还允许在脚本中定义和使用自己的变量，用户变量可以是任何由字母、数字或下划线组成的文本字符串，长度不超过20个，区分大小写。</p><p>使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。</p><p>变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">value1=10<br>value2=<span class="hljs-variable">$value1</span><br> <br><span class="hljs-built_in">echo</span> The resulting value is <span class="hljs-variable">$value2</span><br>--------<br>The resulting value is 10<br>--------<br>value2=value1<br>--------<br>The resulting value is value1<br><span class="hljs-comment"># 没有美元符，shell会将变量名解释成普通的文本字符串</span><br></code></pre></td></tr></table></figure><h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><p>shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋给变量之后，就可以随意在脚本中使用了。</p><p>有两种方法可以将命令输出赋给变量:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">反引号字符<span class="hljs-comment">(`)</span><br>$<span class="hljs-comment">()</span> 格式<br></code></pre></td></tr></table></figure><p>命令替换允许你将shell命令的输出赋给变量，注意，赋值等号和命令替换字符之间没有空格</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">testing=`<span class="hljs-built_in">date</span>`<br>testing=$(<span class="hljs-built_in">date</span>)<br><br>$ <span class="hljs-built_in">cat</span> test5 <br><span class="hljs-comment">#!/bin/bash </span><br>testing=$(<span class="hljs-built_in">date</span>) <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The date and time are: &quot;</span> <span class="hljs-variable">$testing</span> <br>$ <br>$ <span class="hljs-built_in">chmod</span> u+x test5 <br>$ ./test5 <br>The <span class="hljs-built_in">date</span> and time are:  Mon Jan 31 20:23:25 EDT 2014 <br>$ <br></code></pre></td></tr></table></figure><p> 命令替换会创建一个子shell来运行对应的命令。子shell（subshell）是由运行该脚本的shell所创建出来的一个独立的子shell（child shell）。正因如此，由该子shell所执行命令是无法使用脚本中所创建的变量的。<br>  在命令行提示符下使用路径 .&#x2F; 运行命令的话，也会创建出子shell；要是运行命令的时候不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。</p><h2 id="重定向输入和输出"><a href="#重定向输入和输出" class="headerlink" title="重定向输入和输出"></a>重定向输入和输出</h2><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>最基本的重定向将命令的输出发送到一个文件中。bash shell用大于号(&gt;)来输出重定向,</p><p>双大于号（&gt;&gt;）来追加数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> &gt; outputfile<br><span class="hljs-built_in">command</span> &gt;&gt; outputfile <span class="hljs-comment">#追加数据</span><br></code></pre></td></tr></table></figure><h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><p>输入重定向将文件的内容重定向到命令,输入重定向符号是小于号（&lt;）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> &lt; inputfile<br></code></pre></td></tr></table></figure><p>记忆：在命令行上，命令总是在左侧，而重定向符号“指向”数据流动的方向。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">wc</span> &lt; test6<br>      2      11      60<br>  -------------------------------------------------   <br><span class="hljs-built_in">wc</span> 命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值：<br>文本的行数<br>文本的词数<br>文本的字节数<br></code></pre></td></tr></table></figure><p>另外一种输入重定向的方法，称为内联输入重定向（inline input redirection）。这种方法无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据就可以了</p><p>内联输入重定向符号是远小于号（&lt;&lt;）。除了这个符号，你必须指定一个文本标记来划分输入数据的开始和结尾。任何字符串都可作为文本标记，但在数据的开始和结尾文本标记必须一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> &lt;&lt; <span class="hljs-string">marker</span><br><span class="hljs-string">data</span><br><span class="hljs-string">marker</span><br></code></pre></td></tr></table></figure><p>在命令行上使用内联输入重定向时，shell会用 PS2 环境变量中定义的次提示符来提示输入数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">wc</span> &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">&gt; test string 1</span><br><span class="hljs-string">&gt; test string 2</span><br><span class="hljs-string">&gt; test string 3</span><br><span class="hljs-string">&gt; EOF</span><br>      3       9      42 <br>$ <br><span class="hljs-comment"># 次提示符会持续提示，以获取更多的输入数据，直到你输入了作为文本标记的那个字符串。</span><br><span class="hljs-comment"># wc 命令会对内联输入重定向提供的数据进行行、词和字节计数。</span><br></code></pre></td></tr></table></figure><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>将一个命令的输出作为另一个命令的输入,这个过程叫作管道连接（piping）,管道被放在命令之间，将一个命令的输出重定向到另一个命令中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">command1 | command2<br></code></pre></td></tr></table></figure><p>可以利用管道将 rpm 命令的输出送入 sort 命令来产生结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rpm -qa | <span class="hljs-built_in">sort</span><br>abrt-1.1.14-1.fc14.i686 <br>abrt-addon-ccpp-1.1.14-1.fc14.i686 <br>$ rpm -qa | <span class="hljs-built_in">sort</span> &gt; rpm.list<br><span class="hljs-comment"># 可以在一条命令中使用任意多条管道。可以持续地将命令的输出通过管道传给其他命令来细化操作。 </span><br>$ rpm -qa | <span class="hljs-built_in">sort</span> | more <br></code></pre></td></tr></table></figure><h2 id="执行数学运算"><a href="#执行数学运算" class="headerlink" title="执行数学运算"></a>执行数学运算</h2><h3 id="expr-命令（复杂）"><a href="#expr-命令（复杂）" class="headerlink" title="expr 命令（复杂）"></a>expr 命令（复杂）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">expr</span> 1 + 5<br>6<br>$ <span class="hljs-built_in">expr</span> 5 \* 2<br>10<br> <br>var1=10<br>var2=20<br>var3=$(<span class="hljs-built_in">expr</span> <span class="hljs-variable">$var2</span> / <span class="hljs-variable">$var1</span>)<br></code></pre></td></tr></table></figure><h3 id="使用方括号"><a href="#使用方括号" class="headerlink" title="使用方括号"></a>使用方括号</h3><p>在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号<code>$[ operation ] </code>将数学表达式围起来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ var1=$[1 + 5]<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var1</span><br>6<br>$ var2=$[<span class="hljs-variable">$var1</span> * 2]<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$var2</span><br>12<br>$<br></code></pre></td></tr></table></figure><p>bash shell数学运算符只支持整数运算。需要使用bc命令计算， z shell（zsh）提供了完整的浮点数算术操作。</p><h2 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h2><p>shell中运行的每个命令都使用退出状态码（exit status）告诉shell它已经运行完毕。退出状态码是一个0～255的整数值，在命令结束运行时由命令传给shell。可以捕获这个值并在脚本中使用。</p><h3 id="查看退出状态码"><a href="#查看退出状态码" class="headerlink" title="查看退出状态码"></a>查看退出状态码</h3><p>Linux提供了一个专门的变量 $? 来保存上个已执行命令的退出状态码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">date</span><br>Sat Jan 15 10:01:30 EDT 2014<br>$ <span class="hljs-built_in">echo</span> $?<br>0<br></code></pre></td></tr></table></figure><p>按照惯例，一个成功结束的命令的退出状态码是 0 。如果一个命令结束时有错误，退出状态码就是一个正数值。</p><p>Linux退出状态码 </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span> 命令成功结束 <br><span class="hljs-symbol">1 </span> 一般性未知错误 <br><span class="hljs-symbol">2 </span> 不适合的<span class="hljs-keyword">shell</span>命令 <br><span class="hljs-symbol">126 </span> 命令不可执行 <br><span class="hljs-symbol">127 </span> 没找到命令 <br><span class="hljs-symbol">128 </span> 无效的退出参数 <br><span class="hljs-number">128</span>+x  与Linux信号x相关的严重错误 <br><span class="hljs-symbol">130 </span> 通过Ctrl+C终止的命令 <br><span class="hljs-symbol">255 </span> 正常范围之外的退出状态码 <br></code></pre></td></tr></table></figure><h3 id="exit-命令"><a href="#exit-命令" class="headerlink" title="exit 命令"></a>exit 命令</h3><p>默认情况下，shell脚本会以脚本中的最后一个命令的退出状态码退出,exit 命令允许你在脚本结束时指定一个退出状态码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> test13<br><span class="hljs-comment"># !/bin/bash</span><br><span class="hljs-comment"># testing the exit status</span><br>var1=10<br>var2=30<br>var3=$[<span class="hljs-variable">$var1</span> + <span class="hljs-variable">$var2</span>]<br><span class="hljs-built_in">echo</span> The answer is <span class="hljs-variable">$var3</span><br><span class="hljs-built_in">exit</span> 5<br>$<br></code></pre></td></tr></table></figure><p>也可以在 exit 命令的参数中使用变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span> <span class="hljs-variable">$var3</span><br></code></pre></td></tr></table></figure><p>退出状态码超过255时。shell通过模运算计算退出码,最终的结果是指定的数值除以256后得到的余数</p><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令行(5)vim编辑器</title>
    <link href="/2018/02/18/linux-cmd-5-vim-editor/"/>
    <url>/2018/02/18/linux-cmd-5-vim-editor/</url>
    
    <content type="html"><![CDATA[<p>vi编辑器是Unix系统最初的编辑器。它使用控制台图形模式来模拟文本编辑窗口，允许查看文件中的行、在文件中移动、插入、编辑和替换文本<br>在GNU项目将vi编辑器移植到开源世界时，他们决定对其作一些改进。由于它不再是以前Unix中的那个原始的vi编辑器了，开发人员也就将它重命名为vi improved，或vim</p><h2 id="检查-vim-软件包"><a href="#检查-vim-软件包" class="headerlink" title="检查 vim 软件包"></a>检查 vim 软件包</h2><p>在有些发行版中安装的是完整的vim，另外还有一个 vi 命令的别名，</p><p>就像下面所显示的CentOS发行版中的那样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">alias</span> vi<br><span class="hljs-built_in">alias</span> vi=<span class="hljs-string">&#x27;vim&#x27;</span><br>$<br>$ <span class="hljs-built_in">which</span> vim<br>/usr/bin/vim<br>$<br>$ <span class="hljs-built_in">ls</span> -l /usr/bin/vim<br>-rwxr-xr-x. 1 root root 1967072 Apr  5  2012 /usr/bin/vim<br></code></pre></td></tr></table></figure><p>要注意的是，在Ubuntu发行版中不仅没有 vi 命令的别名，而且 &#x2F;usr&#x2F;bin&#x2F;vi 程序属于一系列文件链接中的一环。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">alias</span> vi<br>-bash: <span class="hljs-built_in">alias</span>: vi: not found<br>$<br>$ <span class="hljs-built_in">which</span> vi<br>/usr/bin/vi<br>$<br>$ <span class="hljs-built_in">ls</span> -l /usr/bin/vi<br>lrwxrwxrwx 1 root root 20 Apr 22 12:39 <br>/usr/bin/vi -&gt; /etc/alternatives/vi<br>$<br>$ <span class="hljs-built_in">ls</span> -l /etc/alternatives/vi<br>lrwxrwxrwx 1 root root 17 Apr 22 12:33 <br>/etc/alternatives/vi -&gt; /usr/bin/vim.tiny<br>$<br>$ <span class="hljs-built_in">ls</span> -l /usr/bin/vim.tiny<br>-rwxr-xr-x 1 root root 884360 Jan  2 14:40 <br>/usr/bin/vim.tiny<br>$<br>$ <span class="hljs-built_in">readlink</span> -f /usr/bin/vi<br>/usr/bin/vim.tiny<br></code></pre></td></tr></table></figure><p>当输入 vi 命令时，执行的是程序 &#x2F;usr&#x2F;bin&#x2F;vim.tiny 。 vim.tiny 只提供少量的vim编辑器功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装完整版的vim</span><br>$ sudo apt-get install vim<br></code></pre></td></tr></table></figure><h2 id="vim-基础"><a href="#vim-基础" class="headerlink" title="vim 基础"></a>vim 基础</h2><p>vim编辑器在内存缓冲区中处理数据。通过vim&#x2F;vi命令启动vim编辑器 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim test.c<br></code></pre></td></tr></table></figure><p>vim编辑器有两种操作模式： </p><blockquote><p> 普通模式(默认模式)</p></blockquote><blockquote><p> 插入模式 (<code>i</code>键切换，<code>esc</code>键退出)</p></blockquote><p>vim中有用来移动光标的命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">h ：左移一个字符。<br><span class="hljs-keyword">j </span>：下移一行（文本中的下一行）<br>k ：上移一行（文本中的上一行）<br>l ：右移一个字符<br></code></pre></td></tr></table></figure><p>在大的文本文件中提高移动速度的命令</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">PageDown （或Ctrl+F）：下翻一屏。<br>PageUp （或Ctrl+B）：上翻一屏。<br>G ：移到缓冲区的最后一行。<br><span class="hljs-built_in">num</span> G ：移动到缓冲区中的第 <span class="hljs-built_in">num</span> 行。<br>gg ：移到缓冲区的第一行。<br></code></pre></td></tr></table></figure><h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><p>vim编辑器在普通模式下有个特别的功能叫命令行模式。命令行模式提供了一个交互式命令行，可以输入额外的命令来控制vim的行为在普通模式下按下冒号键进入命令行模式。光标会移动到消息行，然后出现冒号，等待输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">q ：如果未修改缓冲区数据，退出。<br>q! ：取消所有对缓冲区数据的修改并退出。<br>w filename ：将文件保存到另一个文件中。<br>wq ：将缓冲区数据保存到文件中并退出。<br></code></pre></td></tr></table></figure><h3 id="编辑数据"><a href="#编辑数据" class="headerlink" title="编辑数据"></a>编辑数据</h3><p>在普通模式下，vim编辑器提供了一些命令来编辑缓冲区中的数据。 在普通模式下。vim编辑器通常会将删除键（Delete键）识别成 x 命令的功能，删除当前光标所在位置的字符。vim编辑器在普通模式下通常不识别退格键（Backspace键）</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">x  删除当前光标所在位置的字符 <br>dd  删除当前光标所在行 <br>dw  删除当前光标所在位置的单词 <br>d$  删除当前光标所在位置至行尾的内容 <br>J  删除当前光标所在行行尾的换行符（拼接行） <br>u  撤销前一编辑命令 <br>a  在当前光标后追加数据 <br>A  在当前光标所在行行尾追加数据 <br>r char  用char替换当前光标所在位置的单个字符 <br><span class="hljs-section">R text  用text覆盖当前光标所在位置的数据，直到按下ESC键</span><br><span class="hljs-section">---------------------------------------------------------</span><br>2x 会删除从光标当前位置开始的两个字符<br>5dd 会删除从光标当前所在行开始的5行<br></code></pre></td></tr></table></figure><h3 id="复制和粘贴"><a href="#复制和粘贴" class="headerlink" title="复制和粘贴"></a>复制和粘贴</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 剪切(vim在删除数据时，实际上会将数据保存在单独的一个寄存器中)</span><br><span class="hljs-built_in">dd</span><br><span class="hljs-comment"># 复制y(yank)</span><br>y<br><span class="hljs-comment"># 复制一个单词</span><br>yw<br><span class="hljs-comment"># 复制到行尾</span><br>y$<br><span class="hljs-comment"># 粘贴(将文本插入到当前光标所在行之后)</span><br>p<br></code></pre></td></tr></table></figure><h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><p>复制时你无法确定到底复制了什么东西，直到将它粘贴到其他地方才能明白，vim提供了可视模式(v键进入)。</p><p>可视模式会在你移动光标时高亮显示文本。可以用可视模式选取要复制的文本。要进入可视模式，应移动光标到要开始复制的位置，通过v键进入。你会注意到光标所在位置的文本已经被高亮显示了。下一步，移动光标来覆盖你想要复制的文本。在移动光标时，vim会高亮显示复制区域的文本。在覆盖了要复制的文本后，按y键来激活复制命令。现在寄存器中已经有了要复制的文本，移动光标到你要放置的位置，使用 p 命令来粘贴。</p><h3 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h3><p>要输入一个查找字符串，就按下斜线（&#x2F;）键。光标会跑到消息行，然后vim会显示出斜线。在输入你要查找的文本后，按下回车键。vim编辑器会采用以下三种回应中的一种。</p><blockquote><p>如果要查找的文本出现在光标当前位置之后，则光标会跳到该文本出现的第一个位置。</p></blockquote><blockquote><p>如果要查找的文本未在光标当前位置之后出现，则光标会绕过文件末尾，出现在该文本所在的第一个位置（并用一条消息指明）。</p></blockquote><blockquote><p>输出一条错误消息，说明在文件中没有找到要查找的文本。</p></blockquote><p>要继续查找同一个单词，按下斜线键，然后按回车键。或者使用n键，表示下一个（next）。</p><p>替换命令允许你快速用另一个单词来替换文本中的某个单词。必须进入命令行模式才能使用替换命令。替换命令的格式是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">:s/old/new/<br></code></pre></td></tr></table></figure><p>vim编辑器会跳到 old 第一次出现的地方，并用 new 来替换。可以对替换命令作一些修改来替换多处文本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">:s/old/new/g ：一行命令替换所有old<br>:n,ms/old/new/g ：替换行号 n 和 m 之间所有old<br>:%s/old/new/g ：替换整个文件中的所有old<br>:%s/old/new/gc ：替换整个文件中的所有 old ，但在每次出现时提示<br></code></pre></td></tr></table></figure><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令行(4)软件包管理系统(PMS)</title>
    <link href="/2018/02/17/linux-cmd-4-linux-pms/"/>
    <url>/2018/02/17/linux-cmd-4-linux-pms/</url>
    
    <content type="html"><![CDATA[<h2 id="包管理基础"><a href="#包管理基础" class="headerlink" title="包管理基础"></a>包管理基础</h2><p>各种主流Linux发行版都采用了某种形式的包管理系统(package management system,PMS)来控制软件和库的安装。PMS利用一个数据库来记录各种相关内容：<br>Linux系统上已安装了什么软件包；<br>每个包安装了什么文件；<br>每个已安装软件包的版本。</p><p>软件包存储在服务器上，可以利用本地Linux系统上的PMS工具通过互联网访问。这些服务器称为仓库（repository）。可以用PMS工具来搜索新的软件包，或者是更新系统上已安装软件包。 </p><p>软件包通常会依赖其他的包，为了前者能够正常运行，被依赖的包必须提前安装在系统中。PMS工具将会检测这些依赖关系，并在安装需要的包之前先安装好所有额外的软件包。</p><p>PMS的不足之处在于目前还没有统一的标准工具。PMS工具及相关命令在不同的Linux发行版上有很大的不同。Linux中广泛使用的两种主要的PMS基础工具是dpkg和rpm。</p><p>基于Debian的发行版（如Ubuntu和Linux Mint）使用的是 dpkg 命令，这些发行版的PMS工具也是以该命令为基础的。 dpkg 会直接和Linux系统上的PMS交互，用来安装、管理和删除软件包。</p><p>基于Red Hat的发行版（如Fedora、openSUSE及Mandriva）使用的是 rpm 命令，该命令是其PMS的底层基础。类似于 dpkg 命令， rmp 命令能够列出已安装包、安装新包和删除已有软件。</p><h2 id="基于-Debian-的系统"><a href="#基于-Debian-的系统" class="headerlink" title="基于 Debian 的系统"></a>基于 Debian 的系统</h2><p><code>dpkg</code> 命令是基于Debian系PMS工具的核心。包含在这个PMS中的其他工具有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get<br>apt-cache<br>aptitude<br></code></pre></td></tr></table></figure><p>到目前为止，最常用的命令行工具是aptitude,<code>aptitude</code>工具本质上是<code>apt</code>工具和 <code>dpkg</code> 的前端。 <code>dpkg</code>是软件包管理系统工具，而aptitude则是完整的软件包管理系统。<br>命令行下使用 <code>aptitude</code> 命令有助于避免常见的软件安装问题，如软件依赖关系缺失、系统环境不稳定及其他一些不必要的麻烦。本节将会介绍如何在命令行下使用 <code>aptitude </code>命令工具。</p><h3 id="用-aptitude-管理软件包"><a href="#用-aptitude-管理软件包" class="headerlink" title="用 aptitude 管理软件包"></a>用 aptitude 管理软件包</h3><p>aptitude 命令直接进入软件包管理,q退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">aptitude show package_name<br>------------------------------<br>ptitude show mysql-client<br>Package: mysql-client             <br>State: not installed<br>Version: 5.5.38-0ubuntu0.14.04.1<br>...<br></code></pre></td></tr></table></figure><p>无法通过 aptitude 看到的一个细节是所有跟某个特定软件包相关的所有文件的列表。要得到这个列表，就必须用 dpkg 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg -L package_name<br>------------------------------<br>$ dpkg -L vim-common<br>/.<br>/usr/lib/mime/packages<br>/usr/lib/mime/packages/vim-common<br>...<br></code></pre></td></tr></table></figure><p>同样可以进行反向操作，查找某个特定文件属于哪个软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg --search absolute_file_name<br>-------------------------------------<br>$ dpkg --search /usr/bin/xxd<br>vim-common: /usr/bin/xxd<br></code></pre></td></tr></table></figure><h3 id="用-aptitude-安装软件包"><a href="#用-aptitude-安装软件包" class="headerlink" title="用 aptitude 安装软件包"></a>用 aptitude 安装软件包</h3><h4 id="搜索软件包"><a href="#搜索软件包" class="headerlink" title="搜索软件包"></a>搜索软件包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">aptitude search package_name<br>--------------------------------------<br>$ aptitude search wine<br>p  gnome-wine-icon-theme          - red variation of the GNOME- ...<br>v  libkwineffects1-api            - <br>p  libkwineffects1a                - library used by effects...<br>p  q4wine                          - Qt4 GUI <span class="hljs-keyword">for</span> wine (W.I.N.E)<br></code></pre></td></tr></table></figure><p>在每个包名字之前都有一个 p 或 i 。如果看到一个 i ，说明这个包现在已经安装到了你的系统上了。如果看到一个 p 或 v ，说明这个包可用，但还没安装</p><h4 id="从软件仓库中安装软件包。"><a href="#从软件仓库中安装软件包。" class="headerlink" title="从软件仓库中安装软件包。"></a>从软件仓库中安装软件包。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">aptitude install package_name<br>-----------------------------<br>sudo aptitude install wine<br></code></pre></td></tr></table></figure><p>要检查安装过程是否正常，只要再次使用 search 选项就可以了。软件包出现了 i u  ，这说明它已经安装好了。</p><h4 id="用-aptitude-更新软件"><a href="#用-aptitude-更新软件" class="headerlink" title="用 aptitude 更新软件"></a>用 aptitude 更新软件</h4><p>尽管 aptitude 可以帮忙解决安装软件时遇到的问题，但解决有依赖关系的多个包的更新会比较烦琐。要用软件仓库中的新版本妥善地更新系统上所有的软件包，可用 safe-upgrade 选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">aptitude safe-upgrade<br></code></pre></td></tr></table></figure><p>还有一些不那么保守的软件升级选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">aptitude full-upgrade<br>aptitude dist-upgrade<br></code></pre></td></tr></table></figure><p>这些选项执行相同的任务，将所有软件包升级到最新版本。它们同 safe-upgrade 的区别在于，它们不会检查包与包之间的依赖关系。整个包依赖关系问题非常麻烦。如果不是很确定各种包的依赖关系，那还是坚持用 safe-upgrade 选项吧</p><h4 id="用-aptitude-卸载软件"><a href="#用-aptitude-卸载软件" class="headerlink" title="用 aptitude 卸载软件"></a>用 aptitude 卸载软件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#要想只删除软件包而不删除数据和配置文件</span><br>aptitude remove<br><br><span class="hljs-comment">#要删除软件包和相关的数据和配置文件</span><br>aptitude purge<br>---------------------------------------------------<br>sudo aptitude purge wine<br></code></pre></td></tr></table></figure><p>要看软件包是否已删除，可以再用 aptitude 的 search 选项。如果在软件包名称的前面看到一个 c ，意味着软件已删除，但配置文件尚未从系统中清除；如果前面是个 p 的话，说明配置文件也已删除。</p><h4 id="aptitude-仓库"><a href="#aptitude-仓库" class="headerlink" title="aptitude 仓库"></a>aptitude 仓库</h4><p>aptitude 默认的软件仓库位置是在安装Linux发行版时设置的。具体位置存储在文件<code>/etc/apt/sources.lis</code>t中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> /etc/apt/sources.list<br><span class="hljs-comment">#deb cdrom:[Ubuntu 14.04 LTS _Trusty Tahr_ - Release i386 (20140417)]/</span><br>trusty main restricted<br> <br><span class="hljs-comment"># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to</span><br><span class="hljs-comment"># newer versions of the distribution.</span><br>deb http://us.archive.ubuntu.com/ubuntu/ trusty main restricted<br>deb-src http://us.archive.ubuntu.com/ubuntu/ trusty main restricted<br>---------------------------------------<br>deb (or deb-src) address  distribution_name  package_type_list<br>deb 或 deb-src 的值表明了软件包的类型。<br>deb值说明这是一个已编译程序源<br>deb-src值则说明这是一个源代码的源<br>address 条目是软件仓库的Web地址<br>distribution_name 条目是这个特定软件仓库的发行版版本的名称,在这个例子中，发行版名称是trusty<br>package_type_list 条目可能并不止一个词，它还表明仓库里面有什么类型的包。<br>你可以看到诸如main、restricted、universe和partner这样的值<br></code></pre></td></tr></table></figure><h2 id="基于-Red-Hat-的系统"><a href="#基于-Red-Hat-的系统" class="headerlink" title="基于 Red Hat 的系统"></a>基于 Red Hat 的系统</h2><p>和基于Debian的发行版类似，基于Red  Hat的系统也有几种不同的可用前端工具。常见的有以下3种。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum ：在Red Hat和Fedora中使用。<br>urpm ：在Mandriva中使用。<br>zypper ：在openSUSE中使用。<br></code></pre></td></tr></table></figure><p>这些前端都是基于 rpm 命令行工具的</p><h3 id="列出已安装包"><a href="#列出已安装包" class="headerlink" title="列出已安装包"></a>列出已安装包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list installed<br></code></pre></td></tr></table></figure><p>输出的信息可能会在屏幕上一闪而过，所以最好是将已安装包的列表重定向到一个文件中。可以用 more 或 less 命令（或一个GUI编辑器）按照需要查看这个列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list installed &gt; installed_software<br></code></pre></td></tr></table></figure><p>yum 擅长找出某个特定软件包的详细信息。它能给出关于包的非常详尽的描述，另外你还可以通过一条简单的命令查看包是否已安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list package_name<br><br><span class="hljs-comment"># yum list xterm  </span><br>Loaded plugins: langpacks, presto, refresh-packagekit  <br>Adding en_US to language list  <br>Available Packages  <br>xterm.i686 253-1.el6  <br><br><span class="hljs-comment"># yum list installed xterm  </span><br>Loaded plugins: refresh-packagekit <br>Error: No matching Packages to list  <br><span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><p>找出系统上的某个特定文件属于哪个软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum provides file_name<br></code></pre></td></tr></table></figure><h3 id="用-yum-安装软件"><a href="#用-yum-安装软件" class="headerlink" title="用 yum 安装软件"></a>用 yum 安装软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install package_name<br></code></pre></td></tr></table></figure><p>也可以手动下载 rpm 安装文件并用 yum 安装，这叫作本地安装。基本的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum localinstall package_name.rpm<br></code></pre></td></tr></table></figure><h3 id="用-yum-更新软件"><a href="#用-yum-更新软件" class="headerlink" title="用 yum 更新软件"></a>用 yum 更新软件</h3><p>列出所有已安装包的可用更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list updates<br></code></pre></td></tr></table></figure><p>更新某个特定软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum update package_name<br></code></pre></td></tr></table></figure><p>对更新列表中的所有包进行更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum update<br></code></pre></td></tr></table></figure><h3 id="用-yum-卸载软件"><a href="#用-yum-卸载软件" class="headerlink" title="用 yum 卸载软件"></a>用 yum 卸载软件</h3><p>和 aptitude 一样，你需要决定是否保留软件包的数据和配置文件</p><p>只删除软件包而保留配置文件和数据文件,使用remove</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove package_name<br></code></pre></td></tr></table></figure><p>要删除软件和它所有的文件,使用erase</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum erase package_name<br></code></pre></td></tr></table></figure><h3 id="处理损坏的包依赖关系"><a href="#处理损坏的包依赖关系" class="headerlink" title="处理损坏的包依赖关系"></a>处理损坏的包依赖关系</h3><p>有时在安装多个软件包时，某个包的软件依赖关系可能会被另一个包的安装覆盖掉。这叫作损坏的包依赖关系（broken dependency）如果系统出现了这个问题，先试试下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum clean all<br></code></pre></td></tr></table></figure><p>然后试着用 yum update。有时，只要清理了放错位置的文件就可以了。如果这还解决不了问题，试试下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum deplist package_name<br></code></pre></td></tr></table></figure><p>这个命令显示了所有包的库依赖关系以及什么软件可以提供这些库依赖关系,一旦知道某个包需要的库，你就能安装它们了<br>如果这样仍未解决问题，还有最后一招：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum update --skip-broken<br>--skip-broken 选项允许你忽略依赖关系损坏的那个包，继续去更新其他软件包。<br></code></pre></td></tr></table></figure><h3 id="yum-软件仓库"><a href="#yum-软件仓库" class="headerlink" title="yum 软件仓库"></a>yum 软件仓库</h3><p>要想知道你现在正从哪些仓库中获取软件，输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum repolist<br></code></pre></td></tr></table></figure><p>yum 的仓库定义文件位于<code>/etc/yum.repos.d</code></p><h3 id="包信息"><a href="#包信息" class="headerlink" title="包信息"></a>包信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum info package_name<br></code></pre></td></tr></table></figure><h2 id="从源码安装"><a href="#从源码安装" class="headerlink" title="从源码安装"></a>从源码安装</h2><p>在好用的<code> rpm</code> 和 <code>dpkg</code>工具出现之前，管理员必须知道如何从<code>tarball</code>来解包和安装软件。将文件下载到你的Linux系统上，然后解包。<br>要解包一个软件的<code>tarball</code>，用标准的 tar 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf sysstat-11.1.1.tar.gz<br> <br>$ <span class="hljs-built_in">cd</span> sysstat-11.1.1<br>$ <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>在这个目录的列表中，应该能看到README或AAAREADME文件。读这个文件非常重要。该文件中包含了软件安装所需要的操作。<br>按照README文件中的建议，下一步是系统配置。它会检查你的Linux系统，确保它拥有合适的编译器能够编译源代码，另外还要具备正确的库依赖关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure<br></code></pre></td></tr></table></figure><p>如果哪里有错了，在 configure 步骤中会显示一条错误消息说明缺失了什么东西</p><p>用 make 命令来构建各种二进制文件<br>make 命令会编译源码，然后链接器会为这个包创建最终的可执行文件。<br>和configure 命令一样,make 命令会在编译和链接所有的源码文件的过程中产生大量的输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><p>make 步骤结束时，可运行的软件程序就会出现在目录下！但是从那个目录下运行程序有些不便。你会想将它安装到Linux系统中常用的位置上。要这样的话，就必须以root用户身份登录（或者用 sudo 命令，如果你的Linux发行版偏好这个的话），然后用 make 命令的 install 选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make install<br></code></pre></td></tr></table></figure><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令行(3)理解Linux文件权限</title>
    <link href="/2018/02/16/linux-cmd-3-linux-file-permissions/"/>
    <url>/2018/02/16/linux-cmd-3-linux-file-permissions/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux-的安全性"><a href="#Linux-的安全性" class="headerlink" title="Linux 的安全性"></a>Linux 的安全性</h2><p>Linux安全系统的核心是用户账户。每个能进入Linux系统的用户都会被分配唯一的用户账户。用户对系统中各种对象的访问权限取决于他们登录系统时用的账户。用户权限是通过创建用户时分配的用户ID（User ID，通常缩写为UID）来跟踪的</p><h3 id="etc-passwd文件"><a href="#etc-passwd文件" class="headerlink" title="/etc/passwd文件"></a><code>/etc/passwd</code>文件</h3><p>Linux系统使用一个专门的文件来将用户的登录名匹配到对应的UID值。为普通用户创建账户时，大多数Linux系统会从500开始，将第一个可用UID分配给这个账户。root用户账户是Linux系统的管理员，固定分配给它的UID是 0。&#x2F;etc&#x2F;passwd是一个标准的文本文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">root:x:0:0:root:/root:/bin/bash<br>mysql:x:501:501::/home/mysql:/sbin/nologin<br>-----------------------------------<br>/etc/passwd文件的字段包含了如下信息<br>登录用户名<br>用户密码<br>用户账户的UID(数字形式)<br>用户账户的组ID(GID)(数字形式)<br>用户账户的文本描述(称为备注字段)<br>用户HOME目录的位置<br>用户的默认shell<br> <br></code></pre></td></tr></table></figure><p><code>/etc/passwd</code>文件中的密码字段都被设置成了x,，绝大多数Linux系统都将用户密码保存在另一个单独的文件中叫作shadow文件，位置在<code>/etc/shadow</code>）。只有特定的程序（比如登录程序）才能访问这个文件。</p><h3 id="etc-shadow-文件"><a href="#etc-shadow-文件" class="headerlink" title="/etc/shadow 文件"></a><code>/etc/shadow</code> 文件</h3><p><code>/etc/shadow</code>文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问<code>/etc/shadow</code>文件，这让它比起<code>/etc/passwd</code>安全许多。<br><code>/etc/shadow</code>文件为系统上的每个用户账户都保存了一条记录。记录就像下面这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">rich:$1$.FfcK0ns<span class="hljs-variable">$f1UgiyHQ25wrB</span>/hykCn020:11627:0:99999:7:::<br>-------------------------------------<br>在/etc/shadow文件的每条记录中都有9个字段：<br>与/etc/passwd文件中的登录名字段对应的登录名<br>加密后的密码<br>自上次修改密码后过去的天数密码（自1970年1月1日开始计算）<br>多少天后才能更改密码<br>多少天后必须更改密码<br>密码过期前提前多少天提醒用户更改密码 <br>密码过期后多少天禁用用户账户<br>用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）<br>预留字段给将来使用<br></code></pre></td></tr></table></figure><h3 id="添加新用户"><a href="#添加新用户" class="headerlink" title="添加新用户"></a>添加新用户</h3><p>useradd用来向Linux系统添加新用户。</p><p><code>useradd</code> 命令使用系统的默认值以及命令行参数来设置用户账户。系统默认值被设置在<code>/etc/default/useradd</code>文件中。可以使用<code>useradd -D</code>命令查看所用Linux系统中的这些默认值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># /usr/sbin/useradd -D </span><br>GROUP=100 <br>HOME=/home <br>INACTIVE=-1 <br>EXPIRE= <br>SHELL=/bin/bash <br>SKEL=/etc/skel <br>CREATE_MAIL_SPOOL=<span class="hljs-built_in">yes</span> <br><span class="hljs-comment"># </span><br>新用户会被添加到GID为 100 的公共组；<br>新用户的HOME目录将会位于/home/loginname；<br>新用户账户密码在过期后不会被禁用；<br>新用户账户未被设置过期日期；<br>新用户账户将bash shell作为默认shell；<br>系统会将/etc/skel目录下的内容复制到用户的HOME目录下；<br>系统为该用户账户在mail目录下创建一个用于接收邮件的文件。<br>$ <span class="hljs-built_in">ls</span> -al /etc/skel<br>total 32 <br>drwxr-xr-x   2 root root  4096 2010-04-29 08:26 . <br>drwxr-xr-x 135 root root 12288 2010-09-23 18:49 .. <br>-rw-r--r--   1 root root   220 2010-04-18 21:51 .bash_logout <br>-rw-r--r--   1 root root  3103 2010-04-18 21:51 .bashrc <br>-rw-r--r--   1 root root   179 2010-03-26 08:31 examples.desktop <br>-rw-r--r--   1 root root   675 2010-04-18 21:51 .profile <br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -m  创建用户的HOME目录</span><br>useradd -m <span class="hljs-built_in">test</span><br>-c comment  给新用户添加备注 <br>-d home_dir  为主目录指定一个名字（如果不想用登录名作为主目录名的话） <br>-e expire_date  用YYYY-MM-DD格式指定一个账户过期的日期 <br>-f inactive_days  指定这个账户密码过期后多少天这个账户被禁用；0表示密码一过期就立即禁用，1表示<br>禁用这个功能 <br>-g initial_group  指定用户登录组的GID或组名 <br>-G group ...  指定用户除登录组之外所属的一个或多个附加组 <br>-k  必须和-m一起使用，将/etc/skel目录的内容复制到用户的HOME目录 <br>-m  创建用户的HOME目录 <br>-M  不创建用户的HOME目录（当默认设置里要求创建时才使用这个选项） <br>-n  创建一个与用户登录名同名的新组 <br>-r  创建系统账户 <br>-p passwd  为用户账户指定默认密码 <br>-s shell  指定默认的登录shell <br>-u uid  为账户指定唯一的UID <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># useradd -D -s /bin/tsch </span><br>useradd更改默认值的参数 <br>-b default_home  更改默认的创建用户HOME目录的位置 <br>-e expiration_date  更改默认的新账户的过期日期 <br>-f inactive  更改默认的新用户从密码过期到账户被禁用的天数 <br>-g group  更改默认的组名称或GID <br>-s shell  更改默认的登录shell <br></code></pre></td></tr></table></figure><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>默认情况下， <code>userdel </code>命令会只删除<code>/etc/passwd</code>文件中的用户信息，而不会删除系统中属于该账户的任何文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除用户的HOME目录以及邮件目录</span><br>userdel -r <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">usermod <span class="hljs-comment"># 修改用户账户的字段，还可以指定主要组以及附加组的所属关系</span><br>passwd <span class="hljs-comment"># 修改已有用户的密码</span><br>chpasswd <span class="hljs-comment"># 从文件中读取登录名密码对，并更新密码</span><br>chage <span class="hljs-comment"># 修改密码的过期日期</span><br>chfn <span class="hljs-comment"># 修改用户账户的备注信息</span><br>chsh <span class="hljs-comment"># 修改用户账户的默认登录shell</span><br></code></pre></td></tr></table></figure><h5 id="1-usermod"><a href="#1-usermod" class="headerlink" title="1.usermod"></a>1.<code>usermod</code></h5><p><code>usermod</code> 命令是用户账户修改工具中最强大的一个。参数大部分跟 useradd 命令的参数一样.</p><p>-g 修改默认的登录组<br>-l  修改用户账户的登录名。<br>-L 锁定账户，使用户无法登录。<br>-p 修改账户的密码。<br>-U 解除锁定，使用户能够登录。</p><h5 id="2-passwd和chpasswd"><a href="#2-passwd和chpasswd" class="headerlink" title="2.passwd和chpasswd"></a>2.<code>passwd</code>和<code>chpasswd</code></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更改密码</span><br><span class="hljs-comment"># passwd test</span><br>Changing password <span class="hljs-keyword">for</span> user <span class="hljs-built_in">test</span>.<br>New UNIX password:<br>Retype new UNIX password:<br>passwd: all authentication tokens updated successfully.<br></code></pre></td></tr></table></figure><p>如果只用<code>passwd</code>命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只有root用户才有权限改别人的密码。<br>-e 选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制在下次登录时改成他们能记住的更复杂的密码。</p><p>如果需要为系统中的大量用户修改密码，<code>chpasswd</code>命令能从标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。<br>你也可以用重定向命令来将含有<code> userid:passwd</code> 对的文件重定向给该命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chpasswd &lt; users.txt<br></code></pre></td></tr></table></figure><h5 id="3-chsh、chfn和chage"><a href="#3-chsh、chfn和chage" class="headerlink" title="3.chsh、chfn和chage"></a>3.<code>chsh</code>、<code>chfn</code>和<code>chage</code></h5><p><code>chsh </code>、 <code>chfn</code> 和 <code>chage</code> 工具专门用来修改特定的账户信息<br><code>chsh</code> 命令用来快速修改默认的用户登录shell。使用时必须用shell的全路径名作为参数，不能只用shell名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">chsh -s /bin/csh <span class="hljs-built_in">test</span><br>Changing shell <span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span>.<br>Shell changed.<br></code></pre></td></tr></table></figure><p><code>chfn</code> 命令提供了在<code>/etc/passwd</code>文件的备注字段中存储信息的标准方法。 <code>chfn</code> 命令会将用于<br>Unix的<code> finger</code> 命令的信息存进备注字段，而不是简单地存入一些随机文本（比如名字或昵称之类的），或是将备注字段留空。</p><p><code>finger</code>命令可以非常方便地查看Linux系统上的用户信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># finger rich</span><br>Login: rich                            Name: Rich Blum<br>Directory: /home/rich                  Shell: /bin/bash<br>On since Thu Sep 20 18:03 (EDT) on pts/0 from 192.168.1.2<br>No mail.<br>No Plan.<br></code></pre></td></tr></table></figure><p>如果在使用 <code>chfn</code>命令时没有参数，它会向你询问要将哪些适合的内容加进备注字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">chfn <span class="hljs-built_in">test</span><br>Changing finger information <span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span>.<br>Name []: Ima Test<br>Office []: Director of Technology<br>Office Phone []: (123)555-1234<br>Home Phone []: (123)555-9876<br></code></pre></td></tr></table></figure><p><code>chage</code> 命令用来帮助管理用户账户的有效期</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">-d  设置上次修改密码到现在的天数 <br>-E  设置密码过期的日期 <br>-I  设置密码过期到锁定账户的天数 <br>-m  设置修改密码之间最少要多少天 <br>-W  设置密码过期前多久开始出现提醒信息<br></code></pre></td></tr></table></figure><h2 id="Linux-组"><a href="#Linux-组" class="headerlink" title="Linux 组"></a>Linux 组</h2><p>组权限允许多个用户对系统中的对象（比如文件、目录或设备等）共享一组共用的权限。Ubuntu就会为每个用户创建一个单独的与用户账户同名的组。在添加用户前后可用 <code>grep</code> 命令或 <code>tail</code> 命令<br>查看&#x2F;etc&#x2F;group文件的内容比较（<code> grep USERNAME  /etc/group 或 tail /etc/group</code> ）。</p><h4 id="etc-group文件"><a href="#etc-group文件" class="headerlink" title="/etc/group文件"></a><code>/etc/group</code>文件</h4><p>&#x2F;etc&#x2F;group文件包含系统上用到的每个组的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">root:x:0:root<br>bin:x:1:root,bin,daemon<br>daemon:x:2:root,bin,daemon<br>sys:x:3:root,bin,adm<br>jessica:x:503:<br>mysql:x:27:<br><span class="hljs-built_in">test</span>:x:504:<br>----------------------<br>系统账户用的组通常会分配低于500的GID值，而用户组的GID则会从500开始分配。<br>/etc/group文件有4个字段：<br>组名<br>组密码<br>GID<br>属于该组的用户列表<br></code></pre></td></tr></table></figure><h4 id="创建新组-groupadd"><a href="#创建新组-groupadd" class="headerlink" title="创建新组(groupadd)"></a>创建新组(groupadd)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># /usr/sbin/groupadd shared </span><br><span class="hljs-comment"># tail /etc/group </span><br>shared:x:505:<br></code></pre></td></tr></table></figure><p>在创建新组时，默认没有用户被分配到该组。<code>groupadd</code>命令没有提供将用户添加到组中的<br>选项，但可以用 <code>usermod</code> 命令来弥补这一点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># usermod -G shared rich</span><br><span class="hljs-comment"># usermod -G shared test</span><br>-g 指定的组名会替换掉该账户的默认组。<br>-G 将该组添加到用户的属组的列表里，不会影响默认组。<br><span class="hljs-comment"># tail /etc/group </span><br>shared:x:505:rich, <span class="hljs-built_in">test</span> <br><span class="hljs-comment"># </span><br><span class="hljs-comment"># 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更改才能生效。 </span><br></code></pre></td></tr></table></figure><h4 id="修改组-groupmod"><a href="#修改组-groupmod" class="headerlink" title="修改组(groupmod)"></a>修改组(groupmod)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># /usr/sbin/groupmod -n sharing shared  </span><br>-g 修改已有组的GID<br>-n 修改组名<br><span class="hljs-comment"># tail /etc/group </span><br>sharing:x:505:<span class="hljs-built_in">test</span>,rich<br></code></pre></td></tr></table></figure><h2 id="理解文件权限"><a href="#理解文件权限" class="headerlink" title="理解文件权限"></a>理解文件权限</h2><h3 id="使用文件权限符"><a href="#使用文件权限符" class="headerlink" title="使用文件权限符"></a>使用文件权限符</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> –l <br>-rw-rw-r-- 1 rich rich  50 2010-09-13 07:49 file1.gz<br>drwxrwxr-x 2 rich rich 4096 2010-09-03 15:12 test1<br>$<br>-----------------------------------------------------<br>输出结果的第一个字段就是描述文件和目录权限的编码。这个字段的第一个字符代表了对象的类型：<br>- 代表文件<br>d 代表目录<br>l 代表链接<br>c 代表字符型设备<br>b 代表块设备<br>n 代表网络设备<br>之后有3组三字符的编码。每一组定义了3种访问权限：<br>r 代表对象是可读的<br>w 代表对象是可写的<br>x 代表对象是可执行的<br>若没有某种权限，在该权限位会出现单破折线。这3组权限分别对应对象的3个安全级别：<br>对象的属主<br>对象的属组<br>系统其他用户<br> <br>-rwxrwxr-x 1 rich rich 4882 2010-09-18 13:58 myprog<br>文件myprog有下面3组权限。<br>rwx ：文件的属主（设为登录名rich）。<br>rwx ：文件的属组（设为组名rich）。<br>r-x ：系统上其他人。<br></code></pre></td></tr></table></figure><h3 id="默认文件权限"><a href="#默认文件权限" class="headerlink" title="默认文件权限"></a>默认文件权限</h3><p><code>umask</code> 命令用来设置所创建文件和目录的默认权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># touch 命令用分配给我的用户账户的默认权限创建了这个文件</span><br>$ <span class="hljs-built_in">touch</span> newfile <br>$ <span class="hljs-built_in">ls</span> -al newfile <br>-rw-r--r--    1 rich     rich            0 Sep 20 19:16 newfile <br>$ <br><br><span class="hljs-comment"># umask</span><br>0022<br></code></pre></td></tr></table></figure><p><code>umask</code> 值只是个掩码。它会屏蔽掉不想授予该安全级别的权限,要把 <code>umask</code> 值从对象的全权限值中减掉。对文件来说，全权限的值是 666 （所有用户都有读和写的权限）；而对目录来说，则是 777 （所有用户都有读、写、执行权限）</p><h2 id="改变安全性设置"><a href="#改变安全性设置" class="headerlink" title="改变安全性设置"></a>改变安全性设置</h2><h3 id="改变权限"><a href="#改变权限" class="headerlink" title="改变权限"></a>改变权限</h3><p><code>chmod </code>命令用来改变文件和目录的安全性设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> options mode file <br>-R 让权限的改变递归地作用到文件和子目录。你可以使用通配符指定多个文件，然后利用一条命令将权限更改应用到这些文件上。<br><br><span class="hljs-comment"># mode 参数可以使用八进制模式或符号模式进行安全性设置。</span><br><span class="hljs-comment"># 1.八进制模式 设置非常直观，直接用期望赋予文件的标准3位八进制权限码即可。</span><br>$ <span class="hljs-built_in">chmod</span> 760 newfile<br>$ <span class="hljs-built_in">ls</span> -l newfile<br>-rwxrw----    1 rich    rich            0 Sep 20 19:16 newfile<br><br><span class="hljs-comment"># 2.符号模式下指定权限的格式:</span><br>[ugoa…][[+-=][rwxXstugo…]<br>第一组字符定义了权限作用的对象：<br>u 代表用户<br>g 代表组<br>o 代表其他<br>a 代表上述所有<br>下一步，后面跟着的符号表示你是想在现有权限基础上增加权限(+)，还是在现有权限基础上移除权限(-)，或是将权限设置成后面的值(=)。<br>第三个符号代表作用到设置上的权限。额外的设置有以下几项:<br>X ：如果对象是目录或者它已有执行权限，赋予执行权限。<br>s ：运行时重新设置UID或GID。<br>t ：保留文件或目录。<br>u ：将权限设置为跟属主一样。<br>g ：将权限设置为跟属组一样。<br>o ：将权限设置为跟其他用户一样。<br>$ <span class="hljs-built_in">chmod</span> o+r newfile<br><span class="hljs-comment">#ls -F 它能够在具有执行权限的文件名后加一个星号</span><br>$ <span class="hljs-built_in">ls</span> -lF newfile<br>-rwxrw-r--    1 rich    rich            0 Sep 20 19:16 newfile*<br></code></pre></td></tr></table></figure><p>options 为 chmod 命令提供了另外一些功能。 </p><h3 id="改变所属关系"><a href="#改变所属关系" class="headerlink" title="改变所属关系"></a>改变所属关系</h3><p><code>chown </code>改变文件的属主<br><code>chgrp </code>改变文件的默认属组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># chown 命令的格式如下</span><br><span class="hljs-built_in">chown</span> options owner[.group] file<br>-R 选项配合通配符可以递归地改变子目录和文件的所属关系。 <br>-h 选项可以改变该文件的所有符号链接文件的所属关系<br><br><span class="hljs-comment"># 同时改变所在属主和属组</span><br><span class="hljs-comment"># chown dan.shared newfile </span><br><span class="hljs-comment"># ls -l newfile </span><br>-rw-rw-r--    1 dan      shared             0 Sep 20 19:16 newfile <br><span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># chgrp命令可以更改文件或目录的默认属组,用户账户必须是这个文件的属主，除了能够更换属组之外，还得是新组的成员.</span><br>$ <span class="hljs-built_in">chgrp</span> shared newfile<br>$ <span class="hljs-built_in">ls</span> -l newfile<br>-rw-rw-r--    1 rich    shared          0 Sep 20 19:16 newfile<br></code></pre></td></tr></table></figure><h2 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h2><p>Linux系统上共享文件的方法是创建组<br>Linux还为每个文件和目录存储了3个额外的信息位。<br>设置用户ID（<code>SUID</code>）：当文件被用户使用时，程序会以文件属主的权限运行。<br>设置组ID（<code>SGID</code>）：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。<br>粘着位：进程结束后文件还驻留（粘着）在内存中。</p><p><code>SGID</code>位对文件共享非常重要。启用<code>SGID</code>位后，你可以强制在一个共享目录下创建的新文件都属于该目录的属组，这个组也就成为了每个用户的属组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> testdir<br>$ <span class="hljs-built_in">ls</span> -l<br>drwxrwxr-x    2 rich    rich        4096 Sep 20 23:12 testdir/<br>$ <span class="hljs-built_in">chgrp</span> shared testdir<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">chmod</span> g+s testdir  <span class="hljs-comment">#将目录的SGID位置位，以保证目录中新建文件都用shared作为默认属组</span><br>$ <span class="hljs-built_in">ls</span> -l<br>drwxrwsr-x    2 rich    shared      4096 Sep 20 23:12 testdir/<br></code></pre></td></tr></table></figure><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令行(2)Linux环境变量</title>
    <link href="/2018/02/15/linux-cmd-2-linux-enviroment/"/>
    <url>/2018/02/15/linux-cmd-2-linux-enviroment/</url>
    
    <content type="html"><![CDATA[<h2 id="全局环境变量"><a href="#全局环境变量" class="headerlink" title="全局环境变量"></a>全局环境变量</h2><p>全局环境变量对于shell会话和所有生成的子shell都是可见的，局部变量则只对创建它们的shell可见。</p><h3 id="查看全局变量"><a href="#查看全局变量" class="headerlink" title="查看全局变量"></a>查看全局变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">env</span> 或 <span class="hljs-built_in">printenv</span><br></code></pre></td></tr></table></figure><h3 id="显示个别环境变量的值"><a href="#显示个别环境变量的值" class="headerlink" title="显示个别环境变量的值"></a>显示个别环境变量的值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">printenv</span> HOME<br></code></pre></td></tr></table></figure><p>也可以使用 echo 显示变量的值。在这种情况下引用某个环境变量的时候，必须在变量前面加上一个美元符($)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span><br></code></pre></td></tr></table></figure><p>在 echo 命令中，在变量名前加上 $ 可不仅仅是要显示变量当前的值。它能够让变量作为命令行参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> <span class="hljs-variable">$HOME</span><br></code></pre></td></tr></table></figure><h2 id="局部环境变量"><a href="#局部环境变量" class="headerlink" title="局部环境变量"></a>局部环境变量</h2><p>局部环境变量只能在定义它们的进程中可见。在Linux系统并没有一个只显示局部环境变量的命令,<code>set </code>命令 显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">set</span> <br>BASH=/bin/bash <br>[...] <br>BASH_ALIASES=() <br>BASH_ARGC=() <br>BASH_ARGV=() <br>BASH_CMDS=() <br>BASH_LINENO=() <br>BASH_SOURCE=() <br>[...] <br>colors=/etc/DIR_COLORS <br>my_variable=<span class="hljs-string">&#x27;Hello World&#x27;</span> <br>[...] <br>$ <br><span class="hljs-comment">#可以看到，所有通过printenv 命令能看到的全局环境变量都出现在了 set 命令的输出中。但在 set 命令的输出中还有其他一些环境变量，即局部环境变量和用户定义变量。</span><br></code></pre></td></tr></table></figure><h3 id="设置用户定义变量"><a href="#设置用户定义变量" class="headerlink" title="设置用户定义变量"></a>设置用户定义变量</h3><h4 id="设置局部用户定义变量"><a href="#设置局部用户定义变量" class="headerlink" title="设置局部用户定义变量"></a>设置局部用户定义变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$my_variable</span><br><br>$ my_variable=<span class="hljs-string">&quot;Hello World&quot;</span>  <span class="hljs-comment"># 值可以是数值或字符串</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$my_variable</span><br>Hello World<br><br><span class="hljs-comment"># 子shell无法访问父shell定义的局部变量</span><br>$ bash <br>$ <br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$my_variable</span> <br> <br>$ <span class="hljs-built_in">exit</span> <br><span class="hljs-built_in">exit</span> <br>$ <br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$my_variable</span> <br>Hello World <br>$ <br><br><span class="hljs-comment"># 注意: 局部环境变量使用小写字母，系统环境变量使用大写字母</span><br><span class="hljs-comment"># 变量名、等号和值之间没有空格,。如果在赋值表达式中加上了空格，bash  shell就会把值当成一个单独的命令</span><br>$ my_variable = <span class="hljs-string">&quot;Hello World&quot;</span> <br>-bash: my_variable: <span class="hljs-built_in">command</span> not found <br>$ <br><br><br></code></pre></td></tr></table></figure><h4 id="设置全局环境变量"><a href="#设置全局环境变量" class="headerlink" title="设置全局环境变量"></a>设置全局环境变量</h4><p>在设定全局环境变量的进程所创建的子进程中，该变量都是可见的。创建全局环境变量的方法是先创建一个局部环境变量，然后再把它导出到全局环境中。通过<code>export</code> 命令使其变成了全局环境变量，子shell甚至无法使用 export 命令改变父shell中全局环境变量的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ my_variable=<span class="hljs-string">&quot;I am Global now&quot;</span><br>$<br>$ <span class="hljs-built_in">export</span> my_variable<br>$<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$my_variable</span><br>I am Global now<br>$<br>$ bash <br>$ <br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$my_variable</span> <br>I am Global now <br>$ <br>$ <span class="hljs-built_in">exit</span> <br><span class="hljs-built_in">exit</span> <br>$ <br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$my_variable</span> <br>I am Global now <br>$ <br></code></pre></td></tr></table></figure><h3 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$my_variable</span><br>I am Global now<br>$<br>$ <span class="hljs-built_in">unset</span> my_variable<br>$<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$my_variable</span><br><br><span class="hljs-comment"># 如果你是在子进程中删除了一个全局环境变量，这只对子进程有效。该全局环境变量在父进程中依然可用。</span><br>$ my_variable=<span class="hljs-string">&quot;I am Global now&quot;</span> <br>$ <br>$ <span class="hljs-built_in">export</span> my_variable <br>$ <br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$my_variable</span> <br>I am Global now <br>$ <br>$ bash <br>$ <br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$my_variable</span> <br>I am Global now <br>$ <br>$ <span class="hljs-built_in">unset</span> my_variable <br>$ <br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$my_variable</span> <br> <br>$ <span class="hljs-built_in">exit</span> <br><span class="hljs-built_in">exit</span> <br>$ <br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$my_variable</span> <br>I am Global now <br>$ <br></code></pre></td></tr></table></figure><p>如果要用到变量，使用<code>$</code>如果要操作变量，不使用<code>$</code>。这条规则的一个例外就是使用 printenv 显示某个变量的值。</p><h2 id="默认的-shell-环境变量"><a href="#默认的-shell-环境变量" class="headerlink" title="默认的 shell 环境变量"></a>默认的 shell 环境变量</h2><p>默认情况下，bash  shell会用一些特定的环境变量来定义系统环境。bash shell源自当初的Unix Bourne shell，因此也保留了Unix Bourne shell里定义的那些环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># bash shell支持的Bourne变量(部分)</span><br>HOME  当前用户的主目录 <br>IFS  shell用来将文本字符串分割成字段的一系列字符 <br>OPTARG  <span class="hljs-built_in">getopts</span>命令处理的最后一个选项参数值 <br>OPTIND  <span class="hljs-built_in">getopts</span>命令处理的最后一个选项参数的索引号 <br>PATH  shell查找命令的目录列表，由冒号分隔 <br>PS1  shell命令行界面的主提示符 <br>PS2  shell命令行界面的次提示符 <br><br><span class="hljs-comment"># bash shell环境变量(部分)</span><br>BASH  当前shell实例的全路径名 <br>BASH_COMMAND  shell正在执行的命令或马上就执行的命令 <br>BASH_VERSION  当前运行的bash shell的版本号 <br>BASHPID  当前bash进程的PID <br>ENV  如果设置了该环境变量，在bash  shell脚本运行之前会先执行已定义的启动文件（仅用于当bash shell以POSIX模式被调用时） <br>FUNCNAME  当前执行的shell函数的名称<br>GROUPS  含有当前用户属组列表的数组变量 <br>HISTSIZE  最多在历史文件中存多少条命令 <br>HOSTFILE  shell在补全主机名时读取的文件名称 <br>HOSTNAME  当前主机的名称 <br>HOSTTYPE  当前运行bash shell的机器 <br>LANG  shell的语言环境类别<br>PPID  bash shell父进程的PID <br>PWD  当前工作目录 <br>RANDOM  返回一个0～32767的随机数（对其的赋值可作为随机数生成器的种子） <br>SHELL  bash shell的全路径名 <br>TMPDIR  目录名，保存bash shell创建的临时文件 <br>UID  当前用户的真实用户ID（数字形式） <br></code></pre></td></tr></table></figure><h2 id="设置-PATH-环境变量"><a href="#设置-PATH-环境变量" class="headerlink" title="设置 PATH 环境变量"></a>设置 PATH 环境变量</h2><p>当你在shell命令行界面中输入一个外部命令时，shell必须搜索系统来找到对应的程序。 PATH 环境变量定义了用于进行命令和程序查找的目录,PATH 中的目录使用冒号分隔</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ubuntu PATH</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span> <br>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin: <br>/sbin:/bin:/usr/games:/usr/local/games <br>$ <br><br><span class="hljs-comment"># 如果命令或者程序的位置没有包括在 PATH 变量中，那么如果不使用绝对路径的话，shell是没法找到的。如果shell找不到指定的命令或程序，它会产生一个错误信息</span><br>$ myprog <br>-bash: myprog: <span class="hljs-built_in">command</span> not found <br><br><span class="hljs-comment"># 引用原来的 PATH 值，然后再给这个字符串添加新目录</span><br>PATH=<span class="hljs-variable">$PATH</span>:/home/christine/Scripts<br><span class="hljs-comment"># 如果希望子shell也能找到你的程序的位置，一定要记得把修改后的 PATH 环境变量导出</span><br></code></pre></td></tr></table></figure><h2 id="定位系统环境变量"><a href="#定位系统环境变量" class="headerlink" title="定位系统环境变量"></a>定位系统环境变量</h2><p>在你登入Linux系统启动一个bash  shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作启动文件或环境文件。bash检查的启动文件取决于你启动bash  shell的方式。启动bash shell有3种方式： </p><ol><li>登录时作为默认登录shell</li><li>作为非登录shell的交互式shell </li><li>作为运行脚本的非交互shell</li></ol><h3 id="1-登录时作为默认登录shell"><a href="#1-登录时作为默认登录shell" class="headerlink" title="1.登录时作为默认登录shell"></a>1.登录时作为默认登录shell</h3><p>当你登录Linux系统时，bash shell会作为登录shell启动。登录shell会从5个不同的启动文件里读取命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">/etc/profile <br><span class="hljs-variable">$HOME</span>/.bash_profile <br><span class="hljs-variable">$HOME</span>/.bashrc <br><span class="hljs-variable">$HOME</span>/.bash_login <br><span class="hljs-variable">$HOME</span>/.profile <br></code></pre></td></tr></table></figure><p><code>/etc/profile</code>文件是系统上默认的bash  shell的主启动文件。系统上的每个用户登录时都会执行这个启动文件,另外4个启动文件是针对用户的，可根据个人需求定制。</p><h4 id="etc-profile文件"><a href="#etc-profile文件" class="headerlink" title="&#x2F;etc&#x2F;profile文件"></a>&#x2F;etc&#x2F;profile文件</h4><p>&#x2F;etc&#x2F;profile文件是bash  shell默认的的主启动文件。只要你登录了Linux系统，bash就会执行&#x2F;etc&#x2F;profile启动文件中的命令。不同的Linux发行版在这个文件里放了不同的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># centos</span><br><span class="hljs-comment"># /etc/profile</span><br><br><span class="hljs-comment"># System wide environment and startup programs, for login setup</span><br><span class="hljs-comment"># Functions and aliases go in /etc/bashrc</span><br><br><span class="hljs-comment"># It&#x27;s NOT a good idea to change this file unless you know what you</span><br><span class="hljs-comment"># are doing. It&#x27;s much better to create a custom.sh shell script in</span><br><span class="hljs-comment"># /etc/profile.d/ to make custom changes to your environment, as this</span><br><span class="hljs-comment"># will prevent the need for merging in future updates.</span><br><br><span class="hljs-function"><span class="hljs-title">pathmunge</span></span> () &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;:<span class="hljs-variable">$&#123;PATH&#125;</span>:&quot;</span> <span class="hljs-keyword">in</span><br>        *:<span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>:*)<br>            ;;<br>        *)<br>            <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span> = <span class="hljs-string">&quot;after&quot;</span> ] ; <span class="hljs-keyword">then</span><br>                PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$1</span><br>            <span class="hljs-keyword">else</span><br>                PATH=<span class="hljs-variable">$1</span>:<span class="hljs-variable">$PATH</span><br>            <span class="hljs-keyword">fi</span><br>    <span class="hljs-keyword">esac</span><br>&#125;<br><br><br><span class="hljs-keyword">if</span> [ -x /usr/bin/id ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$EUID</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>        <span class="hljs-comment"># ksh workaround</span><br>        EUID=`<span class="hljs-built_in">id</span> -u`<br>        UID=`<span class="hljs-built_in">id</span> -ru`<br>    <span class="hljs-keyword">fi</span><br>    USER=<span class="hljs-string">&quot;`id -un`&quot;</span><br>    LOGNAME=<span class="hljs-variable">$USER</span><br>    MAIL=<span class="hljs-string">&quot;/var/spool/mail/<span class="hljs-variable">$USER</span>&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># Path manipulation</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$EUID</span>&quot;</span> = <span class="hljs-string">&quot;0&quot;</span> ]; <span class="hljs-keyword">then</span><br>    pathmunge /sbin<br>    pathmunge /usr/sbin<br>    pathmunge /usr/local/sbin<br><span class="hljs-keyword">else</span><br>    pathmunge /usr/local/sbin after<br>    pathmunge /usr/sbin after<br>    pathmunge /sbin after<br><span class="hljs-keyword">fi</span><br><br>HOSTNAME=`/bin/hostname 2&gt;/dev/null`<br>HISTSIZE=1000<br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$HISTCONTROL</span>&quot;</span> = <span class="hljs-string">&quot;ignorespace&quot;</span> ] ; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">export</span> HISTCONTROL=ignoreboth<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">export</span> HISTCONTROL=ignoredups<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">export</span> PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL<br><br><span class="hljs-comment"># By default, we want umask to get set. This sets it for login shell</span><br><span class="hljs-comment"># Current threshold for system reserved uid/gids is 200</span><br><span class="hljs-comment"># You could check uidgid reservation validity in</span><br><span class="hljs-comment"># /usr/share/doc/setup-*/uidgid file</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$UID</span> -gt 199 ] &amp;&amp; [ <span class="hljs-string">&quot;`id -gn`&quot;</span> = <span class="hljs-string">&quot;`id -un`&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">umask</span> 002<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">umask</span> 022<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> /etc/profile.d/*.sh ; <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> [ -r <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;-#*i&#125;</span>&quot;</span> != <span class="hljs-string">&quot;$-&quot;</span> ]; <span class="hljs-keyword">then</span><br>            . <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span><br>        <span class="hljs-keyword">else</span><br>            . <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span> &gt;/dev/null 2&gt;&amp;1<br>        <span class="hljs-keyword">fi</span><br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">unset</span> i<br><span class="hljs-built_in">unset</span> -f pathmunge<br><br><br><span class="hljs-comment"># 说明 ubuntu和centos两个发行版的/etc/profile文件都有： for 语句。它用来迭代/etc/profile.d目录下的所有文件。）这为Linux系统提供了一个放置特定应用程序启动文件的地方，当用户登录时，shell会执行这些文件</span><br>$ <span class="hljs-built_in">ls</span> -l /etc/profile.d <br>total 80 <br>-rw-r--r--. 1 root root 1127 Mar  5 07:17 colorls.csh <br>-rw-r--r--. 1 root root 1143 Mar  5 07:17 colorls.sh <br>-rw-r--r--. 1 root root   92 Nov 22  2013 cvs.csh <br><br>不难发现，有些文件与系统中的特定应用有关。大部分应用都会创建两个启动文件：一个供bash shell使用（使用.sh扩展名），一个供c shell使用（使用.csh扩展名）。 lang.csh和lang.sh文件会尝试去判定系统上所采用的默认语言字符集，然后设置对应的 LANG环境变量。 <br></code></pre></td></tr></table></figure><h4 id="HOME目录下的启动文件"><a href="#HOME目录下的启动文件" class="headerlink" title="$HOME目录下的启动文件"></a>$HOME目录下的启动文件</h4><p>剩下的启动文件都起着同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环境变量。大多数Linux发行版只用这四个启动文件中的一到两个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$HOME</span>/.bash_profile<br><span class="hljs-variable">$HOME</span>/.bashrc<br><span class="hljs-variable">$HOME</span>/.bash_login<br><span class="hljs-variable">$HOME</span>/.profile<br></code></pre></td></tr></table></figure><p>shell会按照按照下列顺序，运行第一个被找到的文件，余下的则被忽略：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$HOME</span>/.bash_profile<br><span class="hljs-variable">$HOME</span>/.bash_login<br><span class="hljs-variable">$HOME</span>/.profile<br></code></pre></td></tr></table></figure><p>注意，这个列表中并没有<code>$HOME/.bashrc</code>文件。这是因为该文件通常通过其他文件运行的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># .bash_profile</span><br><br><span class="hljs-comment"># Get the aliases and functions</span><br><span class="hljs-keyword">if</span> [ -f ~/.bashrc ]; <span class="hljs-keyword">then</span><br>. ~/.bashrc<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># User specific environment and startup programs</span><br><br>PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/bin<br><br><span class="hljs-built_in">export</span> PATH<br><br><span class="hljs-comment"># .bash_profile启动文件会先去检查HOME目录中是不是还有一个叫.bashrc的启动文件。如果有的话，会先执行启动文件里面的命令</span><br></code></pre></td></tr></table></figure><h3 id="2-作为非登录shell的交互式shell"><a href="#2-作为非登录shell的交互式shell" class="headerlink" title="2.作为非登录shell的交互式shell"></a>2.作为非登录shell的交互式shell</h3><p>如果你的bash shell不是登录系统时启动的（比如是在命令行提示符下敲入 bash 时启动），那么你启动的shell叫作交互式shell。交互式shell不会像登录shell一样运行，但它依然提供了命令行提示符来输入命令。<br>如果bash是作为交互式shell启动的，它就不会访问&#x2F;etc&#x2F;profile文件，只会检查用户HOME目录中的.bashrc文件。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># .bashrc</span><br><br><span class="hljs-comment"># User specific aliases and functions</span><br><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">rm</span>=<span class="hljs-string">&#x27;rm -i&#x27;</span><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">cp</span>=<span class="hljs-string">&#x27;cp -i&#x27;</span><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">mv</span>=<span class="hljs-string">&#x27;mv -i&#x27;</span><br><br><span class="hljs-comment"># Source global definitions</span><br><span class="hljs-keyword">if</span> [ -f /etc/bashrc ]; <span class="hljs-keyword">then</span><br>. /etc/bashrc<br><span class="hljs-keyword">fi</span><br><span class="hljs-comment"># .bashrc文件有两个作用：一是查看/etc目录下通用的bashrc文件，二是为用户提供一个定制自己的命令别名和私有脚本函数的地方。</span><br></code></pre></td></tr></table></figure><h3 id="3-作为运行脚本的非交互shell"><a href="#3-作为运行脚本的非交互shell" class="headerlink" title="3.作为运行脚本的非交互shell"></a>3.作为运行脚本的非交互shell</h3><p>当shell启动一个非交互式shell进程时，它会检查 BASH_ENV 环境变量来查看要执行的启动文件。如果有指定的文件，shell会执行该文件里的命令，这通常包括shell脚本变量设置。 </p><p>如果父shell是登录shell，在&#x2F;etc&#x2F;profile、&#x2F;etc&#x2F;profile.d&#x2F; * .sh和$HOME&#x2F;.bashrc文件中设置并导出了变量，用于执行脚本的子shell就能够继承这些变量。 </p><h3 id="环境变量持久化"><a href="#环境变量持久化" class="headerlink" title="环境变量持久化"></a>环境变量持久化</h3><p>对全局环境变量来说（Linux系统中所有用户都需要使用的变量），最好是在<code>/etc/profile.d</code>目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中。<br>对个人用户永久性bash shell变量应该放在<code>$HOME/.bashrc</code>文件。</p><h3 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 要给某个环境变量设置多个值，可以把值放在括号里，值与值之间用空格分隔</span><br>mytest=(one two three four five)<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$mytest</span><br>one<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;mytest[2]&#125;</span><br>three<br><span class="hljs-comment"># 要显示整个数组变量，可用星号作为通配符放在索引值的位置</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;mytest[*]&#125;</span><br>one two three four five<br><span class="hljs-comment"># 修改</span><br>mytest[2]=seven<br><span class="hljs-comment"># 删除</span><br>$ <span class="hljs-built_in">unset</span> mytest[2] <br>$ <br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;mytest[*]&#125;</span> <br>one two four five <br>$ <br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;mytest[2]&#125;</span> <br> <br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;mytest[3]&#125;</span> <br>four <br><span class="hljs-comment"># 删除整个数组</span><br>$ <span class="hljs-built_in">unset</span> mytest <br>$ <br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;mytest[*]&#125;</span> <br> <br></code></pre></td></tr></table></figure><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令行(1)Linux Bash Shell命令</title>
    <link href="/2018/02/14/linux-cmd-1-bash-shell-command/"/>
    <url>/2018/02/14/linux-cmd-1-bash-shell-command/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本的bash-shell命令"><a href="#1-基本的bash-shell命令" class="headerlink" title="1. 基本的bash shell命令"></a>1. 基本的bash shell命令</h2><h3 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h3><h4 id="常见Linux目录名称"><a href="#常见Linux目录名称" class="headerlink" title="常见Linux目录名称"></a>常见Linux目录名称</h4><table><thead><tr><th>目    录</th><th>用    途</th></tr></thead><tbody><tr><td>&#x2F;</td><td>虚拟目录的根目录。通常不会在这里存储文件</td></tr><tr><td>&#x2F;bin</td><td>二进制目录，存放许多用户级的GNU工具</td></tr><tr><td>&#x2F;boot</td><td>启动目录，存放启动文件</td></tr><tr><td>&#x2F;dev</td><td>设备目录，Linux在这里创建设备节点</td></tr><tr><td>&#x2F;etc</td><td>系统配置文件目录</td></tr><tr><td>&#x2F;home</td><td>主目录，Linux在这里创建用户目录</td></tr><tr><td>&#x2F;lib</td><td>库目录，存放系统和应用程序的库文件</td></tr><tr><td>&#x2F;media</td><td>媒体目录，可移动媒体设备的常用挂载点</td></tr><tr><td>&#x2F;mnt</td><td>挂载目录，另一个可移动媒体设备的常用挂载点</td></tr><tr><td>&#x2F;opt</td><td>可选目录，常用于存放第三方软件包和数据文件</td></tr><tr><td>&#x2F;proc</td><td>进程目录，存放现有硬件及当前进程的相关信息</td></tr><tr><td>&#x2F;root</td><td>root用户的主目录</td></tr><tr><td>&#x2F;sbin</td><td>系统二进制目录，存放许多GNU管理员级工具</td></tr><tr><td>&#x2F;run</td><td>运行目录，存放系统运作时的运行时数据</td></tr><tr><td>&#x2F;srv</td><td>服务目录，存放本地服务的相关文件</td></tr><tr><td>&#x2F;sys</td><td>系统目录，存放系统硬件信息的相关文件</td></tr><tr><td>&#x2F;tmp</td><td>临时目录，可以在该目录中创建和删除临时工作文件</td></tr><tr><td>&#x2F;usr</td><td>用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里</td></tr><tr><td>&#x2F;var</td><td>可变目录，用以存放经常变化的文件，比如日志文件</td></tr></tbody></table><h4 id="查看帮助命令"><a href="#查看帮助命令" class="headerlink" title="查看帮助命令"></a>查看帮助命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">man <span class="hljs-built_in">command</span><br>e.g. man <span class="hljs-built_in">ls</span><br><br><span class="hljs-built_in">command</span> --<span class="hljs-built_in">help</span><br>e.g. <span class="hljs-built_in">ls</span> --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><h4 id="遍历目录-cd"><a href="#遍历目录-cd" class="headerlink" title="遍历目录(cd)"></a>遍历目录(<code>cd</code>)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> destination<br><span class="hljs-comment"># 绝对文件路径(以斜线/开始)</span><br>christine@server01:~$ <span class="hljs-built_in">cd</span> /usr/bin <br>christine@server01:/usr/bin$  <br><br><span class="hljs-comment"># 当前工作目录</span><br>christine@server01:/usr/bin$ <span class="hljs-built_in">pwd</span> <br>/usr/bin <br><br><span class="hljs-comment"># 相对文件路径</span><br><span class="hljs-comment"># 单点符（.），表示当前目录</span><br><span class="hljs-comment"># 双点符（..），表示当前目录的父目录</span><br>christine@server01:~/Documents$ <span class="hljs-built_in">cd</span> ..<br></code></pre></td></tr></table></figure><h3 id="文件和目录列表-ls"><a href="#文件和目录列表-ls" class="headerlink" title="文件和目录列表(ls)"></a>文件和目录列表(<code>ls</code>)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> option<br>-F 添加指示符,在目录名后加了正斜线（/），在可执行文件的后面加个星号<br>-a 显示隐藏文件和普通文件及目录<br>-R 递归选项,列出了当前目录下包含的子目录中的文件<br>-l 列表格式的输出<br><br>$ <span class="hljs-built_in">ls</span> -l <br>total 48 <br>drwxr-xr-x 2 christine christine 4096 Apr 22 20:37 Desktop <br>-rwxrw-r-- 1 christine christine  54 May 21 11:26 my_script <br><span class="hljs-comment"># 参数说明</span><br><span class="hljs-comment"># 文件类型[目录（ d ）,文件（ - ）,字符型文件（ c ）,块设备（ b ）]</span><br><span class="hljs-comment"># 文件的权限 </span><br><span class="hljs-comment"># 文件的硬链接总数； </span><br><span class="hljs-comment"># 文件属主的用户名； </span><br><span class="hljs-comment"># 文件属组的组名； </span><br><span class="hljs-comment"># 文件的大小（以字节为单位）； </span><br><span class="hljs-comment"># 文件的上次修改时间； </span><br><span class="hljs-comment"># 文件名或目录名。 </span><br><br><span class="hljs-comment"># 过滤输出</span><br><span class="hljs-comment"># 文件扩展匹配（file globbing）</span><br><span class="hljs-comment"># 问号（ ? ）代表一个字符； </span><br><span class="hljs-comment"># 星号（ * ）代表零个或多个字符</span><br>$ <span class="hljs-built_in">ls</span> -l my_scr?pt <br>$ <span class="hljs-built_in">ls</span> -l my* <br><span class="hljs-built_in">ls</span> -l my_scr[ai]pt <br></code></pre></td></tr></table></figure><h3 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h3><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> new_file<br></code></pre></td></tr></table></figure><h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> <span class="hljs-built_in">source</span> destination<br>-p  same as --preserve 保留时间戳，权限等 mode,ownership,timestamps<br>-R, -r, --recursive 递归拷贝 copy directories recursively<br></code></pre></td></tr></table></figure><h4 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">在Linux中有两种不同类型的文件链接： 1.符号链接  2.硬链接 <br><span class="hljs-comment"># 符号链接,一个文件指向存放在虚拟目录结构中某个地方的另一个文件,这两个通过符号链接在一起的文件，彼此的内容并不相同</span><br><span class="hljs-comment"># 创建符号链接</span><br>$ <span class="hljs-built_in">ls</span> -l data_file <br>-rw-rw-r-- 1 christine christine 1092 May 21 17:27 data_file <br>$ <span class="hljs-built_in">ln</span> -s data_file  sl_data_file <br>$ <span class="hljs-built_in">ls</span> -l *data_file <br>-rw-rw-r-- 1 christine christine 1092 May 21 17:27 data_file <br>lrwxrwxrwx 1 christine christine    9 May 21 17:29 sl_data_file -&gt; data_file <br><br><span class="hljs-comment"># 证明链接文件是独立文件,需要查看inode编号。文件或目录的inode编号是一个用于标识的唯一数字，这个数字由内核分配给文件系统中的每一个对象 </span><br>$ <span class="hljs-built_in">ls</span> -i *data_file <br>296890 data_file  296891 sl_data_file <br><br><span class="hljs-comment"># 硬链接,会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们从根本上而言是同一个文件。引用硬链接文件等同于引用了源文件</span><br>$ <span class="hljs-built_in">ls</span> -l code_file <br>-rw-rw-r-- 1 christine christine 189 May 21 17:56 code_file <br>$ <span class="hljs-built_in">ln</span> code_file  hl_code_file <br>$ <span class="hljs-built_in">ls</span> -li *code_file <br>296892 -rw-rw-r-- 2 christine christine 189 May 21 17:56  code_file <br>296892 -rw-rw-r-- 2 christine christine 189 May 21 17:56  hl_code_file <br><span class="hljs-comment"># 注意: 链接计数（列表中第三项）显示这两个文件都有两个链接</span><br><span class="hljs-comment"># 只能对处于同一存储媒体的文件创建硬链接。要想在不同存储媒体的文件之间创建链接，只能使用符号链接。</span><br><br></code></pre></td></tr></table></figure><h4 id="重命名文件-移动-moving"><a href="#重命名文件-移动-moving" class="headerlink" title="重命名文件(移动&#x2F;moving)"></a>重命名文件(移动&#x2F;moving)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># mv 来移动文件的位置</span><br>$ <span class="hljs-built_in">mv</span> src dest<br><br><span class="hljs-comment"># mv 命令移动文件位置并修改文件名称</span><br>$ <span class="hljs-built_in">mv</span> /home/christine/Pictures/fzll  /home/christine/fall <br></code></pre></td></tr></table></figure><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> option file<br>-f  --force 强制删除(ignore nonexistent files and arguments, never prompt)<br>-i  删前提示(prompt before every removal)<br>-r, -R, --recursive 递归删除(remove directories and their contents recursively)<br><br>$ <span class="hljs-built_in">rm</span> -rf file_or_dir<br></code></pre></td></tr></table></figure><h3 id="处理目录"><a href="#处理目录" class="headerlink" title="处理目录"></a>处理目录</h3><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> New_Dir <br>-p, --parents 递归创建目录 no error <span class="hljs-keyword">if</span> existing, make parent directories as needed<br>$ <span class="hljs-built_in">mkdir</span> -p New_Dir/Sub_Dir/Under_Dir <br></code></pre></td></tr></table></figure><h4 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rmdir</span> New_Dir <br><span class="hljs-comment"># 默认情况下， rmdir命令只删除空目录</span><br><span class="hljs-comment"># 可以使用rm递归删除</span><br><span class="hljs-built_in">rm</span> -rf New_Dir<br></code></pre></td></tr></table></figure><h4 id="查看目录-tree"><a href="#查看目录-tree" class="headerlink" title="查看目录(tree)"></a>查看目录(tree)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># tree 工具 :美观的方式展示目录、子目录及其中的文件</span><br>tree <span class="hljs-built_in">dir</span> <br></code></pre></td></tr></table></figure><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><h4 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">file file_name<br><br>$ file my_file <br>my_file: ASCII text <span class="hljs-comment"># 文本文件</span><br>$ file New_Dir <br>New_Dir: directory <span class="hljs-comment"># 目录</span><br>$ file sl_data_file <br>sl_data_file: symbolic <span class="hljs-built_in">link</span> to <span class="hljs-string">&#x27;data_file&#x27;</span>  <span class="hljs-comment"># 符号链接的文件</span><br>$ file my_script <br>my_script: Bourne-Again shell script, ASCII text executable  <span class="hljs-comment"># 脚本文件</span><br>$ file /bin/ls <br>/bin/ls: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV),  <span class="hljs-comment"># 二进制可执行程序</span><br>dynamically linked (uses shared libs), <span class="hljs-keyword">for</span> GNU/Linux 2.6.24,  <br></code></pre></td></tr></table></figure><h4 id="查看整个文件"><a href="#查看整个文件" class="headerlink" title="查看整个文件"></a>查看整个文件</h4><h5 id="1-cat命令"><a href="#1-cat命令" class="headerlink" title="1.cat命令"></a>1.cat命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> file <span class="hljs-comment">#显示文本文件中所有数据</span><br>-n 加上行号<br>-b 给有文本的行加上行号<br></code></pre></td></tr></table></figure><h4 id="2-more命令"><a href="#2-more命令" class="headerlink" title="2.more命令"></a>2.more命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">more file <span class="hljs-comment"># 分页工具</span><br>空格:换页<br>回车:逐行<br>q:退出<br></code></pre></td></tr></table></figure><h5 id="3-less命令"><a href="#3-less命令" class="headerlink" title="3.less命令"></a>3.less命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">less file<br><span class="hljs-comment"># less is more, more命令的升级版</span><br></code></pre></td></tr></table></figure><h4 id="查看部分文件"><a href="#查看部分文件" class="headerlink" title="查看部分文件"></a>查看部分文件</h4><h5 id="1-tail命令"><a href="#1-tail命令" class="headerlink" title="1.tail命令"></a>1.tail命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># tai命令会显示文件最后几行的内容。默认情况下，它会显示文件的末尾10行</span><br><span class="hljs-built_in">tail</span> file<br>-n, --lines=[+]NUM output  the last NUM lines, instead of the last 10; or use -n +NUM to output starting with line NUM 控制显示行数<br>-f, --follow[=&#123;name|descriptor&#125;]<br>              output appended data as the file grows;<br>              an absent option argument means <span class="hljs-string">&#x27;descriptor&#x27;</span><br>              允许你在其他进程使用该文件时查看文件的内容。<span class="hljs-built_in">tail</span> 命令会保持活动状态，并不断显示添加到文件              中的内容。这是实时监测系统日志的绝妙方式。 <br>$ <span class="hljs-built_in">tail</span> -n 2 log_file <span class="hljs-comment"># 显示最后两行</span><br>line19 <br>Last line - line20 <br></code></pre></td></tr></table></figure><h5 id="2-head命令"><a href="#2-head命令" class="headerlink" title="2.head命令"></a>2.head命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># head命令，显示文件开头那些行的内容。默认情况下，它会显示文件前10行的文本.\</span><br><span class="hljs-built_in">head</span> file<br><br><span class="hljs-built_in">head</span> -5 log_file <span class="hljs-comment">#显示5行</span><br></code></pre></td></tr></table></figure><h2 id="2-更多的bash-shell命令"><a href="#2-更多的bash-shell命令" class="headerlink" title="2.更多的bash shell命令"></a>2.更多的bash shell命令</h2><h3 id="监测程序"><a href="#监测程序" class="headerlink" title="监测程序"></a>监测程序</h3><h4 id="探查进程-ps"><a href="#探查进程-ps" class="headerlink" title="探查进程(ps)"></a>探查进程(<code>ps</code>)</h4><p>Linux系统中使用的GNU <code>ps</code> 命令支持3种不同类型的命令行参数： </p><ol><li>Unix风格的参数，前面加单破折线, Unix风格的参数是从贝尔实验室开发的AT&amp;T Unix系统上原有的 ps 命令继承下来的</li><li>BSD风格的参数，前面不加破折线； </li><li>GNU风格的长参数，前面加双破折线。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps option<br><span class="hljs-comment"># Unix风格的ps命令参数 </span><br>-A  显示所有进程 <br>-N  显示与指定参数不符的所有进程 <br>-a  显示除控制进程(session leader)和无终端进程外的所有进程 <br>-d  显示除控制进程外的所有进程 <br>-e  显示所有进程 <br>-C cmdlist  显示包含在cmdlist列表中的进程 <br>-G grplist  显示组ID在grplist列表中的进程 <br>-U userlist  显示属主的用户ID在userlist列表中的进程 <br>-g grplist  显示会话或组ID在grplist列表中的进程<br>-p pidlist  显示PID在pidlist列表中的进程 <br>-s sesslist  显示会话ID在sesslist列表中的进程 <br>-t ttylist  显示终端ID在ttylist列表中的进程 <br>-u userlist  显示有效用户ID在userlist列表中的进程 <br>-F  显示更多额外输出（相对-f参数而言） <br>-O format  显示默认的输出列以及format列表指定的特定列 <br>-M  显示进程的安全信息 <br>-c  显示进程的额外调度器信息 <br>-f  显示完整格式的输出 <br>-j  显示任务信息 <br>-l  显示长列表 <br>-o format  仅显示由format指定的列 <br>-y  不要显示进程标记（process flag，表明进程状态的标记） <br>-Z  显示安全标签（security context） ① 信息 <br>-H  用层级格式来显示进程（树状，用来显示父进程） <br>-n namelist  定义了WCHAN列显示的值 <br>-w  采用宽输出模式，不限宽度显示 <br>-L  显示进程中的线程 <br>-V  显示ps命令的版本号 <br><span class="hljs-comment"># GNU长参数 </span><br>--deselect  显示所有进程，命令行中列出的进程 <br>--Group grplist  显示组ID在grplist列表中的进程 <br>--User userlist  显示用户ID在userlist列表中的进程 <br>--group grplist  显示有效组ID在grplist列表中的进程 <br>--pid pidlist  显示PID在pidlist列表中的进程 <br>--ppid pidlist  显示父PID在pidlist列表中的进程 <br>--sid sidlist  显示会话ID在sidlist列表中的进程 <br>--<span class="hljs-built_in">tty</span> ttylist  显示终端设备号在ttylist列表中的进程 <br>--user userlist  显示有效用户ID在userlist列表中的进程 <br>--format format  仅显示由format指定的列 <br>--context  显示额外的安全信息 <br>--cols n  将屏幕宽度设置为n列 <br>--columns n  将屏幕宽度设置为n列 <br>--cumulative  包含已停止的子进程的信息 <br>--forest  用层级结构显示出进程和父进程之间的关系 <br>--headers  在每页输出中都显示列的头 <br>--no-headers  不显示列的头 <br>--lines n  将屏幕高度设为n行 <br>--rows n  将屏幕高度设为n排 <br>--<span class="hljs-built_in">sort</span> order  指定将输出按哪列排序 <br>--width n  将屏幕宽度设为n列 <br>--<span class="hljs-built_in">help</span>  显示帮助信息 <br>--info  显示调试信息 <br>--version  显示ps命令的版本号 <br><span class="hljs-comment"># 默认情况下， ps命令只会显示运行在当前控制台下的属于当前用户的进程</span><br>$ ps <br>PID TTY          TIME CMD <br>3081 pts/0    00:00:00 bash <br>3209 pts/0    00:00:00 ps <br>$<br><span class="hljs-comment"># -ef选项 -e 参数指定显示所有运行在系统上的进程； -f 参数则扩展了输出</span><br>$ ps -ef <br>UID        PID  PPID  C STIME TTY          TIME CMD <br>root        1    0  0 11:29 ?        00:00:01 init [5] <br>root        2    0  0 11:29 ?        00:00:00 [kthreadd] <br>root      3078  1981  0 12:00 ?        00:00:00 sshd: rich [priv] <br>rich      3080  3078  0 12:00 ?        00:00:00 sshd: rich@pts/0 <br>rich      3081  3080  0 12:00 pts/0    00:00:00 -bash <br>rich      4445  3081  3 13:48 pts/0    00:00:00 ps -ef <br><span class="hljs-comment"># 参数说明</span><br>UID：启动这些进程的用户。 <br>PID：进程的进程ID。 <br>PPID：父进程的进程号（如果该进程是由另一个进程启动的）。 <br>C：进程生命周期中的CPU利用率。 <br>STIME：进程启动时的系统时间。 <br>TTY：进程启动时的终端设备。 <br>TIME：运行进程需要的累计CPU时间。 <br>CMD：启动的程序名称。 <br><br><span class="hljs-comment"># -l 参数，它会产生一个长格式输出。</span><br>$ ps -l <br>F S  UID PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY      TIME  CMD <br>0 S  500 3081  3080  0  80  0 -  1173 <span class="hljs-built_in">wait</span> pts/0  00:00:00 bash <br>0 R  500 4463  3081  1  80  0 -  1116 -    pts/0  00:00:00 ps <br><span class="hljs-comment"># 参数说明</span><br>F ：内核分配给进程的系统标记。 <br>S ：进程的状态（O代表正在运行；S代表在休眠；R代表可运行，正等待运行；Z代表僵化，进程已结束但父进程已不存在；T代表停止）。 <br>PRI ：进程的优先级（越大的数字代表越低的优先级）。 <br>NI ：谦让度值用来参与决定优先级。 <br>ADDR ：进程的内存地址。 <br>SZ ：假如进程被换出，所需交换空间的大致大小。 <br>WCHAN ：进程休眠的内核函数的地址。<br><br><span class="hljs-comment"># 常用ps命令选项</span><br>$ ps -elf<br><br><span class="hljs-comment"># 显示进程树</span><br>$ ps --forest<br></code></pre></td></tr></table></figure><h4 id="实时监测进程-top"><a href="#实时监测进程-top" class="headerlink" title="实时监测进程 (top)"></a>实时监测进程 (top)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs bash">top - 09:42:15 up 10 days,  9:55,  1 user,  load average: 0.00, 0.00, 0.00<br>Tasks:  22 total,  1 running,  21 sleeping,  0 stopped,  0 zombie<br>Cpu(s):  0.3%us,  0.0%sy,  0.0%ni, 99.7%<span class="hljs-built_in">id</span>,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st<br>Mem:    524288k total,  110564k used,  413724k free,        0k buffers<br>Swap:    65536k total,    65536k used,        0k free,    28868k cached<br>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND<br>    1 root      20  0 19232  116  24 S  0.0  0.0  0:00.01 init<br>    3 root      20  0    0    0    0 S  0.0  0.0  0:00.00 khelper/512917<br>  866 mysql    20  0  373m 1336  128 S  0.0  0.3  1:36.24 mysqld<br>  943 root      20  0 1194m  28m 3664 S  0.0  5.6  0:42.29 node<br>11213 root      20  0 11440 1788 1400 S  0.0  0.3  0:00.00 bash<br><br><span class="hljs-comment"># 说明</span><br><span class="hljs-comment">## 第一部分 :系统的概况</span><br><br><span class="hljs-comment"># 第一行显示了当前时间、系统的运行时间、登录的用户数以及系统的平均负载。</span><br><span class="hljs-comment"># 平均负载有3个值：最近1分钟的、最近5分钟的和最近15分钟的平均负载。值越大说明系统的负载越高。由于进程短期的突发性活动，出现最近1分钟的高负载值也很常见，但如果近15分钟内的平均负载都很高，就说明系统可能有问题</span><br><br><span class="hljs-comment"># 第二行显示了进程概要信息—— top命令的输出中将进程叫作任务（task）：有多少进程处在运行、休眠、停止或是僵化状态（僵化状态是指进程完成了，但父进程没有响应）。 </span><br><br><span class="hljs-comment"># 第三行显示了CPU的概要信息。 top 根据进程的属主（用户还是系统）和进程的状态（运行、空闲还是等待）将CPU利用率分成几类输出</span><br><br><span class="hljs-comment"># 第四行显示了系统的物理内存：总共有多少内存，当前用了多少，还有多少空闲</span><br><br><span class="hljs-comment"># 第五行显示了系统交换空间的状态</span><br><br><span class="hljs-comment">## 第二部分：当前运行中的进程的详细列表</span><br><br>PID：进程的ID。 <br>USER：进程属主的名字。 <br>PR：进程的优先级。 <br>NI：进程的谦让度值。 <br>VIRT：进程占用的虚拟内存总量。 <br>RES：进程占用的物理内存总量。 <br>SHR：进程和其他进程共享的内存总量。 <br>S：进程的状态（D代表可中断的休眠状态，R代表在运行状态，S代表休眠状态，T代表跟踪状态或停止状态，Z代表僵化状态）。 <br>%CPU：进程使用的CPU时间比例。 <br>%MEM：进程使用的内存占可用内存的比例。 <br>TIME+：自进程启动到目前为止的CPU时间总量。 <br>COMMAND：进程所对应的命令行名称，也就是启动的程序名。<br><br><span class="hljs-comment"># 默认情况下,top 命令在启动时会按照 %CPU 值对进程排序。可以在 top 运行时使用多种交互命令重新排序。每个交互式命令都是单字符。</span><br>f :选择对输出进行排序的字段，<br>d :修改轮询间隔。<br>q :退出 <br></code></pre></td></tr></table></figure><h4 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h4><h5 id="Linux进程信号"><a href="#Linux进程信号" class="headerlink" title="Linux进程信号"></a>Linux进程信号</h5><p>在Linux中，进程之间通过信号来通信。进程的信号就是预定义好的一个消息，进程能识别它并决定忽略还是作出反应。进程如何处理信号是由开发人员通过编程来决定的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Linux进程信号</span><br>信号 名称  描述 <br>1    HUP  挂起 <br>2    INT  中断 <br>3    QUIT  结束运行 <br>9    KILL  无条件终止 <br>11  SEGV  段错误 <br>15  TERM  尽可能终止 <br>17  STOP  无条件停止运行，但不终止 <br>18  TSTP  停止或暂停，但继续在后台运行 <br>19  CONT  在STOP或TSTP之后恢复执行 <br></code></pre></td></tr></table></figure><h5 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># kill 命令可通过进程ID（PID）给进程发信号。默认情况下， kill 命令会向命令行中列出的全部PID发送一个 TERM 信号</span><br><span class="hljs-comment"># 要发送进程信号，你必须是进程的属主或登录为root用户</span><br><br><span class="hljs-comment"># -s 参数支持指定信号名或信号值</span><br>$ <span class="hljs-built_in">kill</span> -s HUP 3940 <br><br><span class="hljs-comment"># 常用kill命令,强制终止进程</span><br>$ <span class="hljs-built_in">kill</span> -9 3940<br></code></pre></td></tr></table></figure><h5 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># killall 它支持通过进程名而不是PID来结束进程。 killall 命令也支持通配符</span><br>$ killall http* <br></code></pre></td></tr></table></figure><h3 id="监测磁盘空间"><a href="#监测磁盘空间" class="headerlink" title="监测磁盘空间"></a>监测磁盘空间</h3><h4 id="挂载存储媒体"><a href="#挂载存储媒体" class="headerlink" title="挂载存储媒体"></a>挂载存储媒体</h4><p>Linux文件系统将所有的磁盘都并入一个虚拟目录下。在使用新的存储媒体之前，需要把它放到虚拟目录下。这项工作称为挂载（mounting）</p><h5 id="1-mount命令"><a href="#1-mount命令" class="headerlink" title="1.mount命令"></a>1.mount命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Linux上用来挂载媒体的命令叫作mount 。默认情况下， mount命令会输出当前系统上挂载的设备列表</span><br>$ mount <br>proc on /proc <span class="hljs-built_in">type</span> proc (rw) <br>sysfs on /sys <span class="hljs-built_in">type</span> sysfs (rw)<br>/dev/sda1 on /boot <span class="hljs-built_in">type</span> ext3 (rw) <br>sunrpc on /var/lib/nfs/rpc_pipefs <span class="hljs-built_in">type</span> rpc_pipefs (rw) /dev/sdb1 on /media/disk <span class="hljs-built_in">type</span> vfat (rw,nosuid,nodev,uhelper=hal,shortname=lower,uid=503) <br>$ <br><span class="hljs-comment"># mount 命令提供如下四部分信息 </span><br><span class="hljs-comment"># 媒体的设备文件名 </span><br><span class="hljs-comment"># 媒体挂载到虚拟目录的挂载点 </span><br><span class="hljs-comment"># 文件系统类型 </span><br><span class="hljs-comment"># 已挂载媒体的访问状态 </span><br><br><span class="hljs-comment"># 手动在虚拟目录中挂载设备命令</span><br>mount -t <span class="hljs-built_in">type</span> device directory <br><span class="hljs-comment"># type:指定了磁盘被格式化的文件系统类型</span><br><span class="hljs-comment">## vfat：Windows长文件系统。 </span><br><span class="hljs-comment">## ntfs：Windows NT、XP、Vista以及Windows 7中广泛使用的高级文件系统。 </span><br><span class="hljs-comment">## iso9660：标准CD-ROM文件系统。 </span><br><span class="hljs-comment"># device:存储设备的设备文件的位置</span><br><span class="hljs-comment"># directory:挂载点在虚拟目录中的位置</span><br><br><span class="hljs-comment"># 手动将U盘/dev/sdb1挂载到/media/disk</span><br>mount -t vfat /dev/sdb1 /media/disk <br><br><span class="hljs-comment"># mount命令的参数 </span><br>-a  挂载/etc/fstab文件中指定的所有文件系统 <br>-f  使mount命令模拟挂载设备，但并不真的挂载 <br>-F  和-a参数一起使用时，会同时挂载所有文件系统 <br>-v  详细模式，将会说明挂载设备的每一步 <br>-I  不启用任何/sbin/mount.filesystem下的文件系统帮助文件 <br>-l  给ext2、ext3或XFS文件系统自动添加文件系统标签 <br>-n  挂载设备，但不注册到/etc/mtab已挂载设备文件中 <br>-p num  进行加密挂载时，从文件描述符num中获得密码短语 <br>-s  忽略该文件系统不支持的挂载选项 <br>-r  将设备挂载为只读的 <br>-w  将设备挂载为可读写的（默认参数） <br>-L label  将设备按指定的label挂载 <br>-U uuid  将设备按指定的uuid挂载 <br>-O  和-a参数一起使用，限制命令只作用到特定的一组文件系统上 <br>-o  给文件系统添加特定的选项 <br><br>-o 参数允许在挂载文件系统时添加一些以逗号分隔的额外选项。<br><span class="hljs-comment"># 常用的选项。 </span><br>ro ：以只读形式挂载。 <br>rw ：以读写形式挂载。 <br>user ：允许普通用户挂载文件系统。 <br>check=none ：挂载文件系统时不进行完整性校验。 <br>loop ：挂载一个文件。 <br></code></pre></td></tr></table></figure><h5 id="2-umount命令"><a href="#2-umount命令" class="headerlink" title="2.umount命令"></a>2.umount命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 从Linux系统上移除一个可移动设备时，不能直接从系统上移除，而应该先卸载。</span><br><span class="hljs-comment"># umount 命令支持通过设备文件或者是挂载点来指定要卸载的设备</span><br>umount [directory | device ] <br><br><span class="hljs-comment"># 如果有任何程序正在使用设备上的文件，系统就不会允许你卸载它</span><br>[root@testbox mnt]<span class="hljs-comment"># umount /home/rich/mnt </span><br>umount: /home/rich/mnt: device is busy  <br>[root@testbox mnt]<span class="hljs-comment"># cd /home/rich </span><br>[root@testbox rich]<span class="hljs-comment"># umount /home/rich/mnt </span><br>[root@testbox rich]<span class="hljs-comment"># ls -l mnt </span><br>total 0 <br><span class="hljs-comment">#  如果在卸载设备时，系统提示设备繁忙，无法卸载设备，通常是有进程还在访问该设备或使用该设备上的文件。</span><br><span class="hljs-comment">#  这时可用 lsof 命令获得使用它的进程信息，然后在应用中停止使用该设备或停止该进程。 lsof 命令的用法很简</span><br><span class="hljs-comment">#  单： lsof /path/to/device/node ，或者 lsof /path/to/mount/point 。</span><br></code></pre></td></tr></table></figure><h4 id="使用-df-命令"><a href="#使用-df-命令" class="headerlink" title="使用 df 命令"></a>使用 df 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看所有已挂载磁盘的使用情况, df命令会显示每个有数据的已挂载文件系统</span><br>$ <span class="hljs-built_in">df</span> <br>Filesystem          1K-blocks      Used Available Use% Mounted on <br>/dev/sda2            18251068  7703964  9605024  45% / <br>/dev/sda1              101086    18680    77187  20% /boot <br><span class="hljs-comment"># 参数说明</span><br><span class="hljs-comment">## 设备的设备文件位置； </span><br><span class="hljs-comment">## 能容纳多少个1024字节大小的块； </span><br><span class="hljs-comment">## 已用了多少个1024字节大小的块； </span><br><span class="hljs-comment">## 还有多少个1024字节大小的块可用； </span><br><span class="hljs-comment">## 已用空间所占的比例； </span><br><span class="hljs-comment">## 设备挂载到了哪个挂载点上。 </span><br><br><span class="hljs-comment"># 常用选项 -h(human reading)，查看可用空间</span><br>$ <span class="hljs-built_in">df</span> -h <br>Filesystem            Size  Used Avail Use% Mounted on <br>/dev/sdb2              18G  7.4G  9.2G  45% / <br>/dev/sda1              99M  19M  76M  20% /boot <br></code></pre></td></tr></table></figure><h4 id="使用-du-命令"><a href="#使用-du-命令" class="headerlink" title="使用 du 命令"></a>使用 du 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># du命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况</span><br><span class="hljs-comment"># 默认情况下， du 命令会显示当前目录下所有的文件、目录和子目录的磁盘使用情况，它会以磁盘块为单位来表明每个文件或目录占用了多大存储空间。对标准大小的目录来说，这个输出会是一个比较长的列表</span><br>$ <span class="hljs-built_in">du</span> <br>484    ./.gstreamer-0.10 <br>8      ./Templates <br>8      ./Download <br>8      ./.ccache/7/0 <br><span class="hljs-comment"># 每行输出左边的数值是每个文件或目录占用的磁盘块数。注意，这个列表是从目录层级的最底部开始，然后按文件、子目录、目录逐级向上</span><br><br><span class="hljs-comment"># 常见参数</span><br>-c ：显示所有已列出文件总的大小。 <br>-h ：按用户易读的格式输出大小，即用K替代千字节，用M替代兆字节，用G替代吉字节。 <br>-s ：显示每个输出参数的总计。 <br><br><span class="hljs-comment"># 常见用法 查看当前目录所有的文件，目录和子目录的磁盘使用情况</span><br><span class="hljs-built_in">du</span> -h<br></code></pre></td></tr></table></figure><h3 id="处理数据文件"><a href="#处理数据文件" class="headerlink" title="处理数据文件"></a>处理数据文件</h3><h4 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sort命令按照会话指定的默认语言的排序规则对文本文件中的数据行排序</span><br><span class="hljs-built_in">sort</span> [options] file<br><span class="hljs-comment"># sort命令参数 </span><br>-b  --ignore-leading-blanks  排序时忽略起始的空白 <br>-C  --check=quiet  不排序，如果数据无序也不要报告 <br>-c  --check  不排序，但检查输入数据是不是已排序；未排序的话，报告 <br>-d  --dictionary-order  仅考虑空白和字母，不考虑特殊字符 <br>-f  --ignore-case  默认情况下，会将大写字母排在前面；这个参数会忽略大小写 <br>-g  --general-number-sort  按通用数值来排序（跟-n不同，把值当浮点数来排序，支持科学计数法表示的值） <br>-i  --ignore-nonprinting  在排序时忽略不可打印字符 <br>-k  --key=POS1[,POS2]  排序从POS1位置开始；如果指定了POS2的话，到POS2位置结束 <br>-M  --month-sort  用三字符月份名按月份排序 <br>-m  --merge  将两个已排序数据文件合并 <br>-n  --numeric-sort  按字符串数值来排序（并不转换为浮点数） <br>-o  --output=file  将排序结果写出到指定的文件中 <br>-R  --random-sort  按随机生成的散列表的键值排序 <br>  --random-source=FILE  指定-R参数用到的随机字节的源文件 <br>-r  --reverse  反序排序（升序变成降序） <br>-S  --buffer-size=SIZE  指定使用的内存大小 <br>-s  --stable  禁用最后重排序比较 <br>-T  --temporary-directory=DIR  指定一个位置来存储临时工作文件 <br>-t  --field-separator=SEP  指定一个用来区分键位置的字符 <br>-u  --unique  和-c参数一起使用时，检查严格排序；不和-c参数一起用时，仅输出第一例相似的两行 <br>-z  --zero-terminated  用NULL字符作为行尾，而不是用换行符 <br><br><span class="hljs-comment"># 常见用法</span><br><span class="hljs-comment"># /etc/passwd根据用户ID进行数值排序</span><br>$ <span class="hljs-built_in">sort</span> -t <span class="hljs-string">&#x27;:&#x27;</span> -k 3 -n /etc/passwd <br>root:x:0:0:root:/root:/bin/bash <br>bin:x:1:1:bin:/bin:/sbin/nologin <br><br><span class="hljs-comment"># 查看占用空间</span><br>$ <span class="hljs-built_in">du</span> -sh * | <span class="hljs-built_in">sort</span> -nr <br>1008k  mrtg-2.9.29.tar.gz <br>972k    bldg1 <br>888k    fbs2.pdf <br><br></code></pre></td></tr></table></figure><h4 id="搜索数据"><a href="#搜索数据" class="headerlink" title="搜索数据"></a>搜索数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># grep 命令会在输入或指定的文件中查找包含匹配指定模式的字符的行。 grep 的输出就是包含了匹配模式的行</span><br><span class="hljs-comment"># 默认情况下， grep 命令用基本的Unix风格正则表达式来匹配模式</span><br>grep [options] pattern [file]<br><span class="hljs-comment"># 常见参数 </span><br>-v 反向搜索（输出不匹配该模式的行）<br>-n 显示匹配模式的行所在的行号<br>-c 含有匹配的模式行数<br>-e 指定多个匹配模式<br>$ grep -e t -e f file1 <br><br><span class="hljs-comment"># egrep 命令是 grep 的一个衍生，支持POSIX扩展正则表达式。POSIX扩展正则表达式含有更多的可以用来指定匹配模式的字符</span><br><span class="hljs-comment">#  fgrep 则是另外一个版本，支持将匹配模式指定为用换行符分隔的一列固定长度的字符串</span><br><br></code></pre></td></tr></table></figure><h4 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h4><p>#####1. 压缩文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gzip file_name<br></code></pre></td></tr></table></figure><p>#####2.解压文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gunzip file_name<br></code></pre></td></tr></table></figure><h4 id="归档数据"><a href="#归档数据" class="headerlink" title="归档数据"></a>归档数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar <span class="hljs-keyword">function</span> [options] object1 object2 ... <br><span class="hljs-comment"># tar命令的功能 </span><br>-A  --concatenate  将一个已有tar归档文件追加到另一个已有tar归档文件 <br>-c  --create  创建一个新的tar归档文件 <br>-d  --diff  检查归档文件和文件系统的不同之处 <br>  --delete  从已有tar归档文件中删除 <br>-r  --append  追加文件到已有tar归档文件末尾 <br>-t  --list  列出已有tar归档文件的内容 <br>-u  --update  将比tar归档文件中已有的同名文件新的文件追加到该tar归档文件中 <br>-x  --extract  从已有tar归档文件中提取文件 <br><span class="hljs-comment"># tar命令选项 </span><br>-C <span class="hljs-built_in">dir</span>  切换到指定目录 <br>-f file  输出结果到文件或设备file  <br>-j  将输出重定向给bzip2命令来压缩内容 <br>-p  保留所有文件权限 <br>-v  在处理文件时显示文件 <br>-z  将输出重定向给gzip命令来压缩内容 <br></code></pre></td></tr></table></figure><h5 id="1-归档文件"><a href="#1-归档文件" class="headerlink" title="1.归档文件"></a>1.归档文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 文件名以.tgz/.tar.gz结尾 代表是gzip压缩过的tar文件</span><br>tar -zcvf dest.tar.gz file1 dir1<br></code></pre></td></tr></table></figure><p>#####2.列出文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -tf test.tar.gz<br></code></pre></td></tr></table></figure><h6 id="3-提取文件"><a href="#3-提取文件" class="headerlink" title="3.提取文件"></a>3.提取文件</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf test.tar.gz<br></code></pre></td></tr></table></figure><h2 id="3-理解shell"><a href="#3-理解shell" class="headerlink" title="3.理解shell"></a>3.理解shell</h2><h3 id="shell-的父子关系"><a href="#shell-的父子关系" class="headerlink" title="shell 的父子关系"></a>shell 的父子关系</h3><p>用于登录某个虚拟控制器终端或在GUI中运行终端仿真器时所启动的默认的交互shell，是一个父shell</p><p>在CLI提示符后输入 &#x2F;bin&#x2F;bash 命令或其他等效的 bash 命令时，会创建一个新的shell程序。这个shell程序被称为子shell（child shell）。子shell也拥有CLI提示符，同样会等待命令输入.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -f <br>UID        PID  PPID  C STIME TTY          TIME CMD <br>501      1841  1840  0 11:50 pts/0    00:00:00 -bash <br>501      2429  1841  4 13:44 pts/0    00:00:00 ps -f <br>$ <br>$ bash <br>$ <br>$ ps -f <br>UID        PID  PPID  C STIME TTY          TIME CMD <br>501      1841  1840  0 11:50 pts/0    00:00:00 -bash <br>501      2430  1841  0 13:44 pts/0    00:00:00 bash <br>501      2444  2430  1 13:44 pts/0    00:00:00 ps -f <br>$ <br><span class="hljs-comment"># 第一个bash shell程序，也就是父shell进程，其原始进程ID是 1814 。第二个bash shell程序，即子shell进程，其PID是 2430 。注意，子shell的父进程ID（PPID）是 1841 ，指明了这个父shell进程就是该子shell的父进程</span><br><br><span class="hljs-comment">#  bash命令行参数 </span><br>-c string  从string中读取命令并进行处理 <br>-i  启动一个能够接收用户输入的交互shell <br>-l  以登录shell的形式启动 <br>-r  启动一个受限shell，用户会被限制在默认目录中 <br>-s  从标准输入中读取命令 <br></code></pre></td></tr></table></figure><h4 id="查看父子进程之间的关系"><a href="#查看父子进程之间的关系" class="headerlink" title="查看父子进程之间的关系"></a>查看父子进程之间的关系</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -elf --forest<br></code></pre></td></tr></table></figure><h4 id="退出shell"><a href="#退出shell" class="headerlink" title="退出shell"></a>退出shell</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><h3 id="进程列表"><a href="#进程列表" class="headerlink" title="进程列表"></a>进程列表</h3><p>进程列表 生成一个子shell来执行对应的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span> ; <span class="hljs-built_in">ls</span> ; <span class="hljs-built_in">cd</span> /etc ; <span class="hljs-built_in">pwd</span> ; <span class="hljs-built_in">cd</span> ; <span class="hljs-built_in">pwd</span> ; <span class="hljs-built_in">ls</span> ; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$BASH_SUBSHELL</span> <br>Documents  junk.dat  Pictures  Templates <br>0 <br><span class="hljs-comment"># 在命令输出的最后，显示的是数字 0 。这就表明这些命令不是在子shell中运行的</span><br>$ (<span class="hljs-built_in">pwd</span> ; <span class="hljs-built_in">ls</span> ; <span class="hljs-built_in">cd</span> /etc ; <span class="hljs-built_in">pwd</span> ; <span class="hljs-built_in">cd</span> ; <span class="hljs-built_in">pwd</span> ; <span class="hljs-built_in">ls</span> ; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$BASH_SUBSHELL</span>) <br>Documents  junk.dat  Pictures  Templates <br>1 <br><span class="hljs-comment"># 这次在命令输入的最后显示出了数字 1 。这表明的确创建了子shell，并用于执行这些命令。 所以说，命令列表就是使用括号包围起来的一组命令，它能够创建出子shell来执行这些命令</span><br><br><span class="hljs-comment"># 进程列表是一种命令分组（command grouping）。另一种命令分组是将命令放入花括号中，并在命令列表尾部加上分号（;）。语法为 &#123; command; &#125; 。使用花括号进行命令分组并不会像进程列表那样创建出子shel</span><br><br><span class="hljs-comment"># echo $BASH_SUBSHELL 。如果该命令返回 0 ，就表明没有子shell。如果返回1 或者其他更大的数字，就表明存在子shell</span><br></code></pre></td></tr></table></figure><h3 id="别出心裁的子-shell-用法"><a href="#别出心裁的子-shell-用法" class="headerlink" title="别出心裁的子 shell 用法"></a>别出心裁的子 shell 用法</h3><h4 id="后台作业-background-job"><a href="#后台作业-background-job" class="headerlink" title="后台作业(background job)"></a>后台作业(background job)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> &amp;<br>[1] 2396 <span class="hljs-comment"># 1:后台作业号 2396:后台作业进程id</span><br>[1]+ Done <span class="hljs-built_in">command</span> <span class="hljs-comment">#作业完成后的提示</span><br></code></pre></td></tr></table></figure><p>显示当前运行在后台模式中的所有用户的进程(作业)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">jobs</span><br>[1]+ Running <span class="hljs-built_in">command</span><br></code></pre></td></tr></table></figure><h3 id="理解-shell-的内建命令"><a href="#理解-shell-的内建命令" class="headerlink" title="理解 shell 的内建命令"></a>理解 shell 的内建命令</h3><h4 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h4><p>也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于<code>/bin</code>、<code>/usr/bin</code>、<code>/sbin</code>或<code>/usr/sbin</code>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ps就是一个外部命令。你可以使用 which 和 type 命令找到它。</span><br>$ <span class="hljs-built_in">which</span> ps<br>/bin/ps<br>$<br>$ <span class="hljs-built_in">type</span> -a ps<br>ps is /bin/ps<br>$<br>$ <span class="hljs-built_in">ls</span> -l /bin/ps<br>-rwxr-xr-x 1 root root 93232 Jan  6 18:32 /bin/ps<br><span class="hljs-comment"># 当外部命令执行时，会创建出一个子进程。这种操作被称为衍生（forking）。外部命令 ps 很方便显示出它的父进程以及自己所对应的衍生子进程。 </span><br>$ ps -f <br>UID        PID  PPID  C STIME TTY          TIME CMD <br>christi+  2743  2742  0 17:09 pts/9    00:00:00 -bash <br>christi+  2801  2743  0 17:16 pts/9    00:00:00 ps -f <br><br><span class="hljs-comment"># 就算衍生出子进程或是创建了子shell，你仍然可以通过发送信号与其沟通，发送信号（signaling）使得进程间可以通过信号进行通信</span><br></code></pre></td></tr></table></figure><h4 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h4><p>内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体，作为shell工具的组成部分存在。不需要借助外部程序文件来运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># cd 和 exit 命令都内建于bash shell。可以利用 type 命令来了解某个命令是否是内建的。</span><br>$ <span class="hljs-built_in">type</span> <span class="hljs-built_in">cd</span><br><span class="hljs-built_in">cd</span> is a shell <span class="hljs-built_in">builtin</span><br>$<br>$ <span class="hljs-built_in">type</span> <span class="hljs-built_in">exit</span><br><span class="hljs-built_in">exit</span> is a shell <span class="hljs-built_in">builtin</span><br><span class="hljs-comment"># 因为既不需要通过衍生出子进程来执行，也不需要打开程序文件，内建命令的执行速度要更快，效率也更高</span><br></code></pre></td></tr></table></figure><p>要注意，有些命令有多种实现。例如 echo 和 pwd 既有内建命令也有外部命令。两种实现略有不同。要查看命令的不同实现，使用 type 命令的 -a 选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">type</span> -a <span class="hljs-built_in">echo</span><br><span class="hljs-built_in">echo</span> is a shell <span class="hljs-built_in">builtin</span><br><span class="hljs-built_in">echo</span> is /bin/echo<br>$<br>$ <span class="hljs-built_in">which</span> <span class="hljs-built_in">echo</span><br>/bin/echo<br>$<br>$ <span class="hljs-built_in">type</span> -a <span class="hljs-built_in">pwd</span><br><span class="hljs-built_in">pwd</span> is a shell <span class="hljs-built_in">builtin</span><br><span class="hljs-built_in">pwd</span> is /bin/pwd<br>$<br>$ <span class="hljs-built_in">which</span> <span class="hljs-built_in">pwd</span><br>/bin/pwd<br>$<br></code></pre></td></tr></table></figure><p>命令 type -a 显示出了每个命令的两种实现。注意， which 命令只显示出了外部命令文件。</p><h5 id="1-history命令"><a href="#1-history命令" class="headerlink" title="1.history命令"></a>1.history命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看最近用过的命令列表</span><br><span class="hljs-built_in">history</span><br>!! <span class="hljs-comment">#重新执行上一条命令</span><br>!20 <span class="hljs-comment">#唤回历史列表中任意一条命令。只需输入惊叹号和命令在历史列表中的编号即可</span><br><br><span class="hljs-comment"># 命令历史记录被保存在隐藏文件.bash_history中，它位于用户的主目录中。这里要注意的是，bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件中。</span><br>$ <span class="hljs-built_in">history</span> -a <span class="hljs-comment">#强制将命令历史记录提前写入写入</span><br>$ <span class="hljs-built_in">history</span> -n <span class="hljs-comment">#更新终端会话的历史记录</span><br></code></pre></td></tr></table></figure><p>#####2. 命令别名</p><p>alias 命令是另一个shell的内建命令。命令别名允许你为常用的命令（及其参数）创建另一个名称，从而将输入量减少到最低。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看当前可用的别名</span><br><span class="hljs-built_in">alias</span> -p<br><br><span class="hljs-comment">#创建别名 一个别名仅在它所被定义的shell进程中才有效。</span><br><span class="hljs-built_in">alias</span> li=<span class="hljs-string">&#x27;ls -li&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h2><p>《Linux命令行与shell脚本编程大全》第3版</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thymeleaf 3 学习</title>
    <link href="/2017/11/28/thymeleaf-3-study/"/>
    <url>/2017/11/28/thymeleaf-3-study/</url>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>Thymeleaf (麝香草叶子), <strong>&#x2F;ˈtaɪmˌlɪːf&#x2F;</strong> 是一个服务端java模板引擎框架,它能够处理多种数据格式，包括HTML, XML, JavaScript, CSS以及普通文本。</p><h2 id="2-简单的示例"><a href="#2-简单的示例" class="headerlink" title="2.简单的示例"></a>2.简单的示例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-comment">&lt;!--声明 th 名称空间--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Good Thymes Virtual Grocery<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;all&quot;</span> </span><br><span class="hljs-tag">          <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../../css/gtvg.css&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/css/gtvg.css&#125;&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引用文本--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;home.welcome&#125;&quot;</span>&gt;</span>Welcome to our grocery store!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Thymeleaf使用<code>th:*</code> 给现有HTML标签增加属性,因此直接打开模板也能预览效果,很方便 。使用时首先需要像在jsp中一样，在<code>html</code>标签内声明th名称空间，然后就可以使用了。</p><h2 id="3-Standard-Expression-Syntax-标准表达式语法"><a href="#3-Standard-Expression-Syntax-标准表达式语法" class="headerlink" title="3.Standard Expression Syntax(标准表达式语法)"></a>3.Standard Expression Syntax(标准表达式语法)</h2><ul><li>Variable Expressions(变量表达式): <code>$&#123;...&#125;</code></li><li>Selection Variable Expressions(选择变量表达式): <code>*&#123;...&#125;</code></li><li>Message Expressions(消息表达式): <code>#&#123;...&#125;</code></li><li>Link URL Expressions(链接url表达式): <code>@&#123;...&#125;</code></li><li>Fragment Expressions(代码片段表达式): <code>~&#123;...&#125;</code></li></ul><h3 id="1-Messages-信息"><a href="#1-Messages-信息" class="headerlink" title="(1).Messages (信息)"></a>(1).Messages (信息)</h3><p>该表达书主要为了实现i18n国际化，需要将多语言的文本放在<code>/WEB-INF/templates</code>目录下，如下</p><ul><li><code>/WEB-INF/templates/home_en.properties</code> 英文的翻译.</li><li><code>/WEB-INF/templates/home.properties</code> 默认的文本</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--常用使用方法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;home.welcome&#125;&quot;</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br><br><span class="hljs-comment">&lt;!--unescaped text 不转义文本--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:utext</span>=<span class="hljs-string">&quot;#&#123;home.welcome&#125;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以传参给文本</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#home.properties文件</span><br><span class="hljs-attr">home.welcome</span>=<span class="hljs-string">hello, &#123;0&#125;!</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Thymeleaf解析后会将p标签中的Welcome User!替换为th:text指定的文本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;home.welcome($&#123;session.user.name&#125;)&#125;&quot;</span>&gt;</span><br>  Welcome User!<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!--消息的key也可以通过动态去获取  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:utext</span>=<span class="hljs-string">&quot;#&#123;$&#123;welcomeMsgKey&#125;($&#123;session.user.name&#125;)&#125;&quot;</span>&gt;</span><br>  Welcome User!<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>###(2).Variables(变量)</p><p>Thymeleaf的 ${…}是OGNL (Object-Graph Navigation Language) expressions 语法格式，跟jsp中使用方法差不多,使用示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs htm">/*<br>* Access to properties using the point (.). Equivalent to calling property getters.<br>*/<br>$&#123;person.father.name&#125;<br><br>/*<br>* Access to properties can also be made by using brackets ([]) and writing <br>* the name of the property as a variable or between single quotes.<br>*/<br>$&#123;person[&#x27;father&#x27;][&#x27;name&#x27;]&#125;<br><br>/*<br>* If the object is a map, both dot and bracket syntax will be equivalent to <br>* executing a call on its get(...) method.<br>*/<br>$&#123;countriesByCode.ES&#125;<br>$&#123;personsByName[&#x27;Stephen Zucchini&#x27;].age&#125;<br><br>/*<br>* Indexed access to arrays or collections is also performed with brackets, <br>* writing the index without quotes.<br>*/<br>$&#123;personsArray[0].name&#125;<br><br>/*<br>* Methods can be called, even with arguments.<br>*/<br>$&#123;person.createCompleteName()&#125;<br>$&#123;person.createCompleteNameWithSeparator(&#x27;-&#x27;)&#125;<br></code></pre></td></tr></table></figure><h4 id="表达式基本对象-Expression-Basic-Objects-，-开始"><a href="#表达式基本对象-Expression-Basic-Objects-，-开始" class="headerlink" title="表达式基本对象(Expression Basic Objects)，#开始"></a>表达式基本对象(Expression Basic Objects)，#开始</h4><ul><li><p><code>#ctx</code>: the context object. </p></li><li><p><code>#vars:</code> the context variables.</p></li><li><p><code>#locale</code>: the context locale.</p></li><li><p><code>#request</code>: (only in Web Contexts) the <code>HttpServletRequest</code> object.</p></li><li><p><code>#response</code>: (only in Web Contexts) the <code>HttpServletResponse</code> object.</p></li><li><p><code>#session</code>: (only in Web Contexts) the <code>HttpSession</code> object.</p></li><li><p><code>#servletContext</code>: (only in Web Contexts) the <code>ServletContext</code> object.</p></li></ul><h5 id="表达式工具对象"><a href="#表达式工具对象" class="headerlink" title="表达式工具对象"></a>表达式工具对象</h5><ul><li><code>#execInfo</code>: information about the template being processed. </li><li><code>#messages</code>: methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax.</li><li><code>#uris</code>: methods for escaping parts of URLs&#x2F;URIs</li><li><code>#conversions</code>: methods for executing the configured <em>conversion service</em> (if any).</li><li><code>#dates</code>: methods for <code>java.util.Date</code> objects: formatting, component extraction, etc.</li><li><code>#calendars</code>: analogous to <code>#dates</code>, but for <code>java.util.Calendar</code> objects.</li><li><code>#numbers</code>: methods for formatting numeric objects.</li><li><code>#strings</code>: methods for <code>String</code> objects: contains, startsWith, prepending&#x2F;appending, etc.</li><li><code>#objects</code>: methods for objects in general.</li><li><code>#bools</code>: methods for boolean evaluation.</li><li><code>#arrays</code>: methods for arrays.</li><li><code>#lists</code>: methods for lists.</li><li><code>#sets</code>: methods for sets.</li><li><code>#maps</code>: methods for maps.</li><li><code>#aggregates</code>: methods for creating aggregates on arrays or collections.</li><li><code>#ids</code>: methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--表达式工具对象的使用--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>  Today is: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#calendars.format(today,&#x27;dd MMMM yyyy&#x27;)&#125;&quot;</span>&gt;</span>13 May 2011<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-Expressions-on-selections-asterisk-syntax-选择表达式-星号语法"><a href="#3-Expressions-on-selections-asterisk-syntax-选择表达式-星号语法" class="headerlink" title="(3).Expressions on selections (asterisk syntax)(选择表达式 - 星号语法)"></a>(3).Expressions on selections (asterisk syntax)(选择表达式 - 星号语法)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:object</span>=<span class="hljs-string">&quot;$&#123;session.user&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;firstName&#125;&quot;</span>&gt;</span>Sebastian<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Surname: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;lastName&#125;&quot;</span>&gt;</span>Pepper<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nationality: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;nationality&#125;&quot;</span>&gt;</span>Saturn<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 等价于 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;session.user.firstName&#125;&quot;</span>&gt;</span>Sebastian<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Surname: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;session.user.lastName&#125;&quot;</span>&gt;</span>Pepper<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nationality: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;session.user.nationality&#125;&quot;</span>&gt;</span>Saturn<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 还可以混合使用--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:object</span>=<span class="hljs-string">&quot;$&#123;session.user&#125;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;firstName&#125;&quot;</span>&gt;</span>Sebastian<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Surname: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;session.user.lastName&#125;&quot;</span>&gt;</span>Pepper<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nationality: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;nationality&#125;&quot;</span>&gt;</span>Saturn<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- #object 引用表达式的对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:object</span>=<span class="hljs-string">&quot;$&#123;session.user&#125;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#object.firstName&#125;&quot;</span>&gt;</span>Sebastian<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Surname: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;session.user.lastName&#125;&quot;</span>&gt;</span>Pepper<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nationality: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;nationality&#125;&quot;</span>&gt;</span>Saturn<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>th:object</code>定义选择的对象,在标签内使用<code>*&#123;...&#125;</code>来取出对象中相应的数据，如果没有选择的对象直接使用<code>*&#123;...&#125;</code>等价于<code>#&#123;...&#125;</code></p><p>###(4).Link URLs(链接URL)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Will produce &#x27;http://localhost:8080/gtvg/order/details?orderId=3&#x27; (plus rewriting) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;details.html&quot;</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;http://localhost:8080/gtvg/order/details(orderId=$&#123;o.id&#125;)&#125;&quot;</span>&gt;</span>view<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Will produce &#x27;/gtvg/order/details?orderId=3&#x27; (plus rewriting) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;details.html&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/order/details(orderId=$&#123;o.id&#125;)&#125;&quot;</span>&gt;</span>view<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- Will produce &#x27;/gtvg/order/3/details&#x27; (plus rewriting) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;details.html&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/order/&#123;orderId&#125;/details(orderId=$&#123;o.id&#125;)&#125;&quot;</span>&gt;</span>view<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-Literals-文本"><a href="#5-Literals-文本" class="headerlink" title="(5).Literals(文本)"></a>(5).Literals(文本)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 基本的使用--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>  Now you are looking at a <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;working web application&#x27;&quot;</span>&gt;</span>template file<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The year is <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;2013&quot;</span>&gt;</span>1492<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br><br><span class="hljs-comment">&lt;!-- ==false 需要写在&#123;&#125;外面才交由thymeleaf处理，写在里面时交由 OGNL/SpringEL处理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;user.isAdmin()&#125; == false&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;user.isAdmin() == false&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!--判空--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;variable.something&#125; == null&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 文本链接 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;The name of the user is &#x27; + $&#123;user.name&#125;&quot;</span>&gt;</span><br>  <br>  <br>  <span class="hljs-comment">&lt;!-- 文本替换,(免去+号链接字符串),需要写在 || 之间</span><br><span class="hljs-comment">        仅变量，信息表达式可以使用$&#123;...&#125;, *&#123;...&#125;, #&#123;...&#125;</span><br><span class="hljs-comment">--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;|Welcome to our application, $&#123;user.name&#125;!|&quot;</span>&gt;</span><br>    <br>    <br></code></pre></td></tr></table></figure><h3 id="6-Arithmetic-operations-算术操作"><a href="#6-Arithmetic-operations-算术操作" class="headerlink" title="(6).Arithmetic operations(算术操作)"></a>(6).Arithmetic operations(算术操作)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 也可以使用文本 div (/), mod (%).--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;isEven=($&#123;prodStat.count&#125; % 2 == 0)&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-Comparators-and-Equality-比较"><a href="#7-Comparators-and-Equality-比较" class="headerlink" title="(7).Comparators and Equality(比较)"></a>(7).Comparators and Equality(比较)</h3><p>html起止标签的缘故，大于，小于等需要使用转义</p><p><code>gt</code> (<code>&gt;</code>), <code>lt</code> (<code>&lt;</code>), <code>ge</code> (<code>&gt;=</code>), <code>le</code> (<code>&lt;=</code>), <code>not</code> (<code>!</code>) <code>eq</code> (<code>==</code>), <code>neq</code>&#x2F;<code>ne</code> (<code>!=</code>).</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;prodStat.count&#125; <span class="hljs-symbol">&amp;gt;</span> 1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;Execution mode is &#x27; + ( ($&#123;execMode&#125; == &#x27;dev&#x27;)? &#x27;Development&#x27; : &#x27;Production&#x27;)&quot;</span> </span><br></code></pre></td></tr></table></figure><h3 id="8-Conditional-expressions-条件表达式"><a href="#8-Conditional-expressions-条件表达式" class="headerlink" title="(8).Conditional expressions(条件表达式)"></a>(8).Conditional expressions(条件表达式)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--C中的三元运算符 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:class</span>=<span class="hljs-string">&quot;$&#123;row.even&#125;? &#x27;even&#x27; : &#x27;odd&#x27;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 省略--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:class</span>=<span class="hljs-string">&quot;$&#123;row.even&#125;? &#x27;alt&#x27;&quot;</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="9-Default-expressions-Elvis-operator-默认表达式"><a href="#9-Default-expressions-Elvis-operator-默认表达式" class="headerlink" title="(9). Default expressions (Elvis operator) 默认表达式"></a>(9). Default expressions (Elvis operator) 默认表达式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:object</span>=<span class="hljs-string">&quot;$&#123;session.user&#125;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Age: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;age&#125;?: &#x27;(no age specified)&#x27;&quot;</span>&gt;</span>27<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 等价于,省略表达式为true时的语句 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Age: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;age != null&#125;? *&#123;age&#125; : &#x27;(no age specified)&#x27;&quot;</span>&gt;</span>27<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="10-The-No-Operation-token-空操作符"><a href="#10-The-No-Operation-token-空操作符" class="headerlink" title="(10). The No-Operation token(空操作符)"></a>(10). The No-Operation token(空操作符)</h3><p>空操作符( No-Operation token)使用下划线表示<code>_</code>，它允许原生页面定义的文本为默认值,便于模板的设计</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.name&#125; ?: &#x27;no user authenticated&#x27;&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.name&#125; ?: _&quot;</span>&gt;</span>no user authenticated<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="11-Data-Conversion-Formatting-数据转换-格式化"><a href="#11-Data-Conversion-Formatting-数据转换-格式化" class="headerlink" title="(11). Data Conversion &#x2F; Formatting (数据转换&#x2F;格式化)"></a>(11). Data Conversion &#x2F; Formatting (数据转换&#x2F;格式化)</h3><p>Thymeleaf 定义了双花括号语法用于变量<code>$&#123;...&#125;</code>和选择表达式<code>*&#123;...&#125;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;&#123;user.lastAccessDate&#125;&#125;&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-Iteration-遍历"><a href="#4-Iteration-遍历" class="headerlink" title="4.Iteration(遍历)"></a>4.Iteration(遍历)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>NAME<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>PRICE<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>IN STOCK<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;prod,iterStat : $&#123;prods&#125;&quot;</span> <span class="hljs-attr">th:class</span>=<span class="hljs-string">&quot;$&#123;iterStat.odd&#125;? &#x27;odd&#x27;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;prod.name&#125;&quot;</span>&gt;</span>Onions<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;prod.price&#125;&quot;</span>&gt;</span>2.41<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;</span>&gt;</span>yes<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="th-each说明"><a href="#th-each说明" class="headerlink" title="th:each说明"></a>th:each说明</h3><p><code>prod</code>保存每次遍历的对象，<code>iterStat</code>保存遍历的相关信息</p><ul><li>The current <em>iteration index</em>, starting with 0. This is the <code>index</code> property. 遍历索引，从0开始</li><li>The current <em>iteration index</em>, starting with 1. This is the <code>count</code> property. 遍历计数，从1开始</li><li>The total amount of elements in the iterated variable. This is the <code>size</code> property.  被遍历对象的大小 </li><li>The <em>iter variable</em> for each iteration. This is the <code>current</code> property. 当前遍历的对象</li><li>Whether the current iteration is even or odd. These are the <code>even/odd</code> boolean properties. 奇偶布尔值</li><li>Whether the current iteration is the first one. This is the <code>first</code> boolean property. 是否是遍历第一个</li><li>Whether the current iteration is the last one. This is the <code>last</code> boolean property. 是否是遍历最后一个</li></ul><h3 id="被遍历的对象类型"><a href="#被遍历的对象类型" class="headerlink" title="被遍历的对象类型"></a>被遍历的对象类型</h3><ul><li>Any object implementing <code>java.util.Iterable</code></li><li>Any object implementing <code>java.util.Enumeration</code>.</li><li>Any object implementing <code>java.util.Iterator</code>, whose values will be used as they are returned by the iterator, without the need to cache all values in memory.</li><li>Any object implementing <code>java.util.Map</code>. When iterating maps, iter variables will be of class <code>java.util.Map.Entry</code>.</li><li>Any array.</li><li>Any other object will be treated as if it were a single-valued list containing the object itself.</li></ul><h2 id="5-Conditional-Evaluation-条件表达式"><a href="#5-Conditional-Evaluation-条件表达式" class="headerlink" title="5.Conditional Evaluation(条件表达式)"></a>5.Conditional Evaluation(条件表达式)</h2><h3 id="if和unless语句"><a href="#if和unless语句" class="headerlink" title="if和unless语句"></a>if和unless语句</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 如果if表达式成立则显示该标签--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;comments.html&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/product/comments(prodId=$&#123;prod.id&#125;)&#125;&quot;</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;not #lists.isEmpty(prod.comments)&#125;&quot;</span>&gt;</span>view<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--还可以使用相反的表达式unless --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;comments.html&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/comments(prodId=$&#123;prod.id&#125;)&#125;&quot;</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">th:unless</span>=<span class="hljs-string">&quot;$&#123;#lists.isEmpty(prod.comments)&#125;&quot;</span>&gt;</span>view<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="if遵循的规则"><a href="#if遵循的规则" class="headerlink" title="if遵循的规则"></a>if遵循的规则</h4><ul><li>If value is not null:<ul><li>If value is a boolean and is <code>true</code>.</li><li>If value is a number and is non-zero</li><li>If value is a character and is non-zero</li><li>If value is a String and is not “false”, “off” or “no”</li><li>If value is not a boolean, a number, a character or a String.</li></ul></li><li>(If value is null, th:if will evaluate to false).</li></ul><h3 id="switch-case语句"><a href="#switch-case语句" class="headerlink" title="switch&#x2F;case语句"></a>switch&#x2F;case语句</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:switch</span>=<span class="hljs-string">&quot;$&#123;user.role&#125;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;&#x27;admin&#x27;&quot;</span>&gt;</span>User is an administrator<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;#&#123;roles.manager&#125;&quot;</span>&gt;</span>User is a manager<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;*&quot;</span>&gt;</span>User is some other thing<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-comment">&lt;!--默认值--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="6-Template-Layout-模板布局"><a href="#6-Template-Layout-模板布局" class="headerlink" title="6.Template Layout (模板布局)"></a>6.Template Layout (模板布局)</h2><p>使用<code>th:fragment</code>定义需要复用的代码片段，<code>th:insert</code>或<code>th:replac</code>引用片段</p><p><code>~&#123;templatename::selector&#125;</code> 引用片段 </p><p><code>~&#123;templatename&#125;</code>引用整个文件 </p><p><code>~&#123;::selector&#125;</code>或<code>~&#123;this::selector&#125;</code>引用自身的代码片段 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--定义代码片段 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;copy&quot;</span>&gt;</span><br>      <span class="hljs-symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 引用代码片 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:insert</span>=<span class="hljs-string">&quot;footer :: copy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 根据条件引用--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:insert</span>=<span class="hljs-string">&quot;footer :: ($&#123;user.isAdmin&#125;? #&#123;footer.admin&#125; : #&#123;footer.normaluser&#125;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!-- 根据id引用 css选择器语法类似--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;copy-section&quot;</span>&gt;</span><br>  <span class="hljs-symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:insert</span>=<span class="hljs-string">&quot;~&#123;footer :: #copy-section&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="th-insert-th-replace-th-include"><a href="#th-insert-th-replace-th-include" class="headerlink" title="th:insert , th:replace ,th:include"></a><code>th:insert</code> , <code>th:replace</code> ,<code>th:include</code></h5><ul><li><p><code>th:insert</code> is the simplest: it will simply insert the specified fragment as the body of its host tag. (在定义的标签体内引用代码片段)</p></li><li><p><code>th:replace</code> actually <em>replaces</em> its host tag with the specified fragment.(将定义标签替换为引用的代码片段)</p></li><li><p><code>th:include</code> is similar to <code>th:insert</code>, but instead of inserting the fragment it only inserts the <em>contents</em> of this fragment.(Thymeleaf 3.0后不推荐使用)</p><h5 id="参数化方式引用代码片段-Parameterizable-fragment-signatures"><a href="#参数化方式引用代码片段-Parameterizable-fragment-signatures" class="headerlink" title="参数化方式引用代码片段(Parameterizable fragment signatures)"></a>参数化方式引用代码片段(Parameterizable fragment signatures)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--定义参数化代码片段--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;frag (onevar,twovar)&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;onevar&#125; + &#x27; - &#x27; + $&#123;twovar&#125;&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!--使用 使用参数名时顺序不重要 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;::frag ($&#123;value1&#125;,$&#123;value2&#125;)&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;::frag (onevar=$&#123;value1&#125;,twovar=$&#123;value2&#125;)&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;::frag (twovar=$&#123;value2&#125;,onevar=$&#123;value1&#125;)&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="7-Local-Variables-局部变量"><a href="#7-Local-Variables-局部变量" class="headerlink" title="7.Local Variables(局部变量)"></a>7.Local Variables(局部变量)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 使用th:with定义,可以再标签体中使用--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;firstPer=$&#123;persons[0]&#125;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    The name of the first person is <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;firstPer.name&#125;&quot;</span>&gt;</span>Julius Caesar<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8.参考资料"></a>8.参考资料</h2><p>1.Thymleaf Document(<a href="http://www.thymeleaf.org/documentation.html">http://www.thymeleaf.org/documentation.html</a>)</p><p>2.属性优先级(<a href="http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#attribute-precedence">http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#attribute-precedence</a>)</p><p>3.可用属性(<a href="http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#setting-value-to-specific-attributes">http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#setting-value-to-specific-attributes</a>)</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
